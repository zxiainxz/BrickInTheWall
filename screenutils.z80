; scadd - calculate the screen address
; inputs: h - x coordinate
;         l - y coordinate
; outputs: address in de
scadd:                  
                        push af

                        ld a, l
                        ; ld e, a                 ; store y in e

                        ; find line within cell

                        and 7                   ; lime 0-7 within char square
                        add a, 64               ; 64 * 256 = 16384 = start of screen display
                        ld d, a                 ; line * 256

                        ; find which third of the screen we're in

                        ld a, l                 ; restore y coord
                        and 192                 ; segment 0, 1 or 2 multiplied by 64
                        rrca                    ; divide this by 8
                        rrca
                        rrca                    ; segment 0-2 multiplied by 8
                        add a, d                ; add to d to give segment start address
                        ld d, a

                        ; find character cell within segment

                        ld a, l                 ; 8 char cells per segment
                        rlca                    ; divide y by 8 & multiply by 32
                        rlca                    ; net calculation: multiply by 4
                        and 224                 ; mask off bits we don't want
                        ld e, a                 ; vertical coordinate calculation done

                        ; add horizontal element

                        ld a, h
                        rrca                    ; only need to dovode by 8
                        rrca
                        rrca
                        and 31                  ; squares 0 - 31 across screen
                        add a, e                ; add to total so far
                        ld e, a                 ; de = screen address

                        pop af
                        
                        ret

; nextrow - calculates the screen address of the next row
; inputs: a  - y coordinate of the current row
;         de - screen address of the current row
; outputs: de - the address of the next row
;          a - new y coord
nextrow:
                        push hl                 ; save hl
                        ld hl, de               ; move screen address into hl

                        inc a                   ; move to next row
                        push af

                        and 63                  ; are we moving to the next third of the screen
                        jr z, nextthird
                        and 7                   ; are we moving to the next character
                        jr z, nextchar
                        ;dec hl                  ; left two bytes
                        ;dec l                   ; not straddling 256-byte boundary
                        inc h                   ; next row of this character cell
nextrowdone:
                        ld de, hl               ; move new screen address back into de

                        pop af
                        pop hl                  ; restore hl
                        ret

nextthird:
                        ld de, 32               ; next segment is 32 bytes on
                        add hl, de              ; add to the screen address
                        jr nextrowdone

nextchar:
                        ld de, 63776            ; minus 1760
                        add hl, de              ; subtract 1760 from screen address
                        jr nextrowdone

; NextRow2: get the next row quicker than nextrow
; Inputs:  de - current screen address
; Outputs: de - new screen address
; Trashes: af
NextRow2:                                                       ; Better than nextrow
                        inc d
                        ld a, d
                        and 0x07
                        ret nz

                        ld a, e
                        add a, 32
                        ld e, a
                        ret c

                        ld a, d
                        sub 8
                        ld d, a

                        ret

NextCharRow:
                        ld a, e
                        add a, 32
                        ld e, a

                        ret nc

                        add d, 8
                        ld d, a
                        
                        ret
; atadd - get the attribute address
; inputs: hl - x, y coordinates in character space
; outputs: de - attribute address
atadd:
                        push af                 ; protect af

                        ld a, l                 ; load y coord into a
                        rrca                    ; * 32
                        rrca
                        rrca
                        ld e, a                 ; store y * 32 into e
                        and 3                   ; mask the bits for moving into high byte
                        add a, 88               ; 88 * 256 = 22528 = ATTR_BASE
                        ld d, a                 ; move to d (*256)
                        ld a, e                 ; put y * 32 back into a
                        and 224                 ; mask low byte
                        ld e, a                 ; store into e
                        ld a, h
                        add a, e                ; add x coord to low byte
                        ld e, a                 ; store into e

                        pop af                  ; restore af
                        ret

; pixelattradd - get the attribute address of a given pixel
; inputs: hl - x, y coordinates in pixel space
; outputs: de - attribute address
pixelattradd:
                        push hl

                        srl h                    ; divide x and y by 8
                        srl h                    ; to get them into character space
                        srl h
                        srl h
                        sla h
                        srl l
                        srl l
                        srl l

                        call atadd

                        pop hl
                        ret


ClearScreen:
                        ld hl, $4000
                        ld de, $4001
                        ld bc, 6144
                        ld (hl), l
                        ldir

                        ld a, 56
                        ld bc, 767
                        ld (hl), a
                        ldir
                        ret

ClearAttrs:
                        ld hl, $5800
                        ld de, $5801
                        ld a, 56
                        ld bc, 767
                        ld (hl), a
                        ldir
                        ret

FadeScreenToWhite:
                        call ClearAttrs
                        ld bc, 0x0800
ClearCharRow:

                        ld a, 23
ClearNextCharRow:
                        push af
                        
                        add a
                        add a
                        add a

                        add b
                        sub 1

                        ld h, 0
                        ld l, a

                        call scadd
                        call ClearRow

                        pop af

                        dec a
                        cp 255
                        jr nz, ClearNextCharRow

                        halt
                        halt
                        halt      

                        inc c
                        djnz ClearCharRow

                        ret

ClearRow
                        push af
                        push bc

                        ld b, 32

                        xor a
ClearBlock              ld (de), a
                        inc de

                        djnz ClearBlock

                        pop bc
                        pop af
                        ret

; Draw a vertical line
; a - bit location of line
; de - screen address
DrawVerticalLine8:
                        push bc

                        ld b, 8
                        ex af, af'
                        ld a, l
                        ex af, af'

DrawNextLine:
                        ld c, a
                        ld a, (de)
                        or c
                        ld (de), a
                        ld a, c

                        ex af, af'
                        call nextrow
                        ex af, af'

                        djnz DrawNextLine   
                        pop bc
                        ret

; Erase a vertical line
; a - bits to erase
; de - screen address
EraseVerticalLine8:
                        push bc

                        ld b, 8
                        ex af, af'
                        ld a, l
                        ex af, af'

EraseNextLine:
                        ld c, a
                        ld a, (de)

                        xor c
                        ld (de), a
                        ld a, c

EraseMoveToNextLine:
                        ex af, af'
                        call nextrow
                        ex af, af'

                        djnz EraseNextLine   
                        pop bc
                        ret

CopyBackBufferToScreen:
                        ld (CBBTS_SP+1), sp

                        ld hl, BACKBUFFER_BASE
                        exx
                        ld hl, SCREEN_BASE
CBBTS_NextLine:
                        ; ld (CBBTS_SCREEN1+1), hl
                        exx

                        ld sp, hl

                        pop af, bc, de, ix

                        exx
                        ex af, af'

                        ld de, 16
                        add hl, de

                        pop af, bc, de, iy

                        ld (CBBTS_BUFFER1+1), sp

                        ld sp, hl
                        push iy, de, bc, af

                        ex af, af'
                        exx

                        push ix, de, bc, af

CBBTS_BUFFER1:
                        ld hl, 0
                        ld sp, hl

                        pop af, bc, de, ix
                        exx
                        ex af, af'

                        ld de, 16
                        add hl, de

                        pop af, bc, de, iy

                        ld (CBBTS_BUFFER2+1), sp
                        ld sp, hl

                        push iy, de, bc, af

                        ex af, af'
                        exx

                        push ix, de, bc, af

CBBTS_BUFFER2:
                        ld hl, 0
                        exx

CBBTS_SCREEN1:
                        ld a, h
                        cp 0x58
                        jr nz, CBBTS_NextLine
                        
CBBTS_SP:               ld sp, 0
                        exx
                        ret
