; DrawSprite8x8 - Draws a 8x8 sprite on the screen at (xcoord, ycoord)
; Inputs: ix - Start address of the sprite data
;         de - screen address
;         hl - x, y
DrawSprite8x8:
                        push bc

                        ld b, 8                         ; Size of sprite
DrawRow:
                        push bc

                        ld b, (ix)                      ; sprite in b
                        ld c, 0                         ; empty sprite in c

                        ld a, h                         ; Load x coord into a
                        and 7                           ; how many shifts required
                        jr z, DrawFirstPart             ; 0 shifts, so only need to draw the b sprite

                        cp 5                            ; Check if it's quick to shift left
                        jr nc, ShiftLeft

                        and a                           ; clear carry
DoShift:
                        rr b                            ; roll right, overflow into carry
                        rr c                            ; roll right, picking up any overflow from b
                        dec a                           ; and loop
                        jr nz, DoShift

ShiftComplete:
                        inc e                           ; move to next char

                        ld a, (de)                      ; what's already there
                        xor c                           ; xor with 2nd part of the shifted sprite
                        ld (de), a                      ; put it onto the screen

                        dec e                           ; move back to the first char

DrawFirstPart:
                        ld a, (de)                      ; what's already on the screen
                        xor b                           ; xor the 1st part of the shifted sprite
                        ld (de), a                      ; put it on the screen

LineDrawn:
                        pop bc

                        call NextRow2                    ; get the next row address
                        inc ix

                        djnz DrawRow

                        pop bc
                        ret

ShiftLeft:
                        xor 7                           ; flip the last 3 bits to get the number of left shifts
                        inc a
ShiftLeft1:
                        rl b                            ; roll b left, overflow into carry
                        rl c                            ; roll c left, getting overflow from carry

                        dec a
                        jr nz, ShiftLeft1               ; loop

                                                        ; At this point the 1st part of the shifted sprite is in c
                                                        ; and b has the second part, but the sprite drawing part
                                                        ; wants the 1st part in b and the second in c, so switch
                        ld a, b
                        ld b, c
                        ld c, a
                        jr ShiftComplete

; de - screen address
; ix - sprite data
OverdrawSprite8x8NoShift:
                        push bc

                        ld b, 8                         ; Size of sprite
OverdrawRow:
                        ld a, (ix)                      ; what's already on the screen
                        ld (de), a                      ; put it on the screen

                        call NextRow2                    ; get the next row address
                        inc ix

                        djnz OverdrawRow

                        pop bc
                        ret

; DrawSprite16x8 - Draws a 8x8 sprite on the screen at (xcoord, ycoord)
; Inputs: ix - Start address of the sprite data
;         de - screen adderess
;          h - x coordinate
;          l - y coordinate
DrawSprite16x8:
                        push bc
                        push hl

                        ld a, h
                        ld (tmpx), a

                        ld b, 8

DrawRow16:
                        push bc

                        ld b, (ix)
                        ld c, (ix+1)
                        ld h, 0

                        ld a, (tmpx)
                        and 7
                        jr z, Draw16

                        cp 5                            ; Check if it's quick to shift left
                        jr nc, Shift16Left

                        and a
DoShift16:
                        rr b
                        rr c
                        rr h
                        dec a
                        jr nz, DoShift16

Shift16Complete:
                        inc e
                        inc e

                        ld a, (de)
                        xor h
                        ld (de), a

                        dec e
                        dec e

Draw16:
                        ld a, (de)
                        xor b
                        ld (de), a

                        ld (de), a
                        inc e

                        ld a, (de)
                        xor c
                        ld (de), a

                        dec e

                        ex af, af'

                        ld bc, 2
                        add ix, bc

                        pop bc

                        call NextRow2
                        
                        djnz DrawRow16

                        pop hl
                        pop bc

                        ret

Shift16Left:
                        xor 7                           ; flip the last 3 bits to get the number of left shifts
                        inc a
Shift16Left1:
                        rl c
                        rl b
                        rl h

                        dec a
                        jr nz, Shift16Left1               ; loop

                        ld a, c
                        ld c, b
                        ld b, h
                        ld h, a
                        jr Shift16Complete

ClearSprite16x8:
                        push bc
                        push hl

                        ld a, l
                        ld b, 8

                        ex af, af'
                        xor a
                        ex af, af'

ClearNextRow:
                        ex af, af'

                        ld (de), a
                        inc de
                        ld (de), a

                        dec de

                         ex af, af'

                        call NextRow2
                        
                        djnz ClearNextRow

                        pop hl
                        pop bc

                        ret

; CheckCollision8v16: Check for a collision between an 8 sprite and a 16 sprite
; Inputs: a - one coord
;         c - other coord
; Outputs: sets z on collision
CheckCollision8v16:
                        sub c                                   ; xcoord  - batx

                        add 7                                   ; add 7 to prevent negative

                        cp 23                                   ; compare to total width 8 + 16

                        ret nc

                        cp a                                    ; there was a collision, so set z
                        ret

CheckCollision8v8:
                        sub c
                        add 7
                        cp 15
                        ret nc
                        cp a
                        ret

CheckCollision8v4:
                        sub c
                        add 3
                        cp 11
                        ret nc
                        cp a
                        ret

; CheckCollision8v16x8v8 - Checks for collisions between two objects, one 8x8 and one 16x8
; Inputs: hl - x,y of one object
;         bc - x,y of the second object
; Outputs: z set on collision
; Trashes: a
CheckCollision8v16x8v8:
                        ld a, l                                 ; y coord
                        sub c                                   ; subtract other y
                        add a, 7                                ; add max distance
                        cp 15
                        jr z, CheckX8v16x8v8
                        ret nc
CheckX8v16x8v8                       
                        ld a, h                                 ; x coord
                        sub b                                   ; subtract other x
                        add 7                                   ; add max distance
                        cp 23
                        ret nc
                        cp a
                        ret

CheckColllision6v16x6v8:
                        ld a, l
                        sub c
                        add a, 5
                        cp 13
                        jr z, CheckX6v16x6v8
                        ret nc
CheckX6v16x6v8:
                        ld a, h
                        sub b
                        add a, 5
                        cp 21
                        ret nc
                        cp a
                        ret

DrawBallSprite:
                        ld ix, Ball_Data
                        call DrawSprite8x8
                        ret

; da na na na na na na na batsprite!
DrawBatSprite:
                        ld ix, Bat_Data
                        call DrawSprite16x8
                        ret

DrawAllSprites:
                        ld ix, spritetable
                        ld b, MAX_SPRITES

ProcessNextSprite:
                        ld c, (ix+SPRITETABLE_FLAGS)
                        ld a, c
                        and 1
                        cp 0
                        jr z, NextSprite

                        ld a, c                                         ; Restore flags

                        ld hl, (ix+SPRITETABLE_Y)

                        push ix

                        ld de, (ix+SPRITETABLE_DATA)
                        ld ix, de

                        call scadd
                        and %00000010

                        push hl

                        cp 0
                        jr z, Sprite8x8
                        call DrawSprite16x8
                        jr SpriteDrawn
Sprite8x8:
                        call DrawSprite8x8

SpriteDrawn:
                        pop hl
                        pop ix
                        ld (ix+SPRITETABLE_OLD_Y), hl
                        
NextSprite:
                        ld de, SPRITETABLE_SIZE
                        add ix, de
                        djnz ProcessNextSprite

                        ret

; This code is 99% identical to DrawAllSprites, except for where it takes
; the coords from. It could be shared by using some self modifying code
; but I don't know how that would work with the interrupts
EraseAllSprites:
                        ld ix, spritetable
                        ld b, MAX_SPRITES

ProcessEraseNextSprite:
                        ld c, (ix+SPRITETABLE_FLAGS)
                        ld a, c
                        and 1
                        cp 0
                        jr z, EraseNextSprite

                        ld a, c                                         ; Restore flags

                        ld hl, (ix+SPRITETABLE_OLD_Y)

                        push ix

                        ld de, (ix+SPRITETABLE_DATA)
                        ld ix, de

                        call scadd
                        and %00000010

                        push hl

                        cp 0
                        jr z, EraseSprite8x8
                        call DrawSprite16x8
                        jr SpriteErased
EraseSprite8x8:
                        call DrawSprite8x8

SpriteErased:
                        pop hl
                        pop ix
                        ; ld (ix+SPRITETABLE_OLD_Y), hl
                        
EraseNextSprite:
                        ld de, SPRITETABLE_SIZE
                        add ix, de
                        djnz ProcessEraseNextSprite

                        ret


InitialliseSpriteTable:
                        ld b, MAX_SPRITES
                        ld ix, spritetable
InitNextSprite:
                        xor a

                        ld (ix+SPRITETABLE_FLAGS), a

                        ld de, SPRITETABLE_SIZE
                        add ix, de

                        djnz InitNextSprite
                        ret