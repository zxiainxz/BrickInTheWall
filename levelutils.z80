; Points ix to the current level
LoadCurrentLevel:
                        push hl                                 ; store hl

                        ld h, 0                                 ; load the current level into hl
                        ld a, (currentlevel)
                        ld l, a
                        add hl, hl                              ; double it because we're accessing memory offsets

                        ld de, levels                           ; load the levels table
                        add hl, de                              ; point hl to the current level

                        ld a, (hl)                              ; get the address of the level in hl
                        inc hl
                        ld h, (hl)
                        ld l, a

                        ld ix, hl                               ; copy hl to ix

                        pop hl                                  ; restore
                        ret

; Inputs: hl: pixel coords (including offset)
; Outputs: hl: address of corresponding brick in level map
Pixel2LevelMap:
                        ld a, l
                        sub 32
                        ld l, a
                        ; fall thru to PixelNoOffset2LevelMap
PixelNoOffset2LevelMap:
                        push de

                        ld de, LevelMap

                        srl h
                        srl h
                        srl h
                        srl h

                        ld a, l                             
                        add a
                        add h

                        ld h, 0
                        ld l, a

                        add hl, de

                        pop de
                        ret

; inputs b - brick x, c - brick y
; outputs: h - pixel x, l - pixel y
Brick2Pixel:
                        push af

                        ld a, b
                        add a, a
                        add a, a
                        add a, a
                        add a, a

                        ld h, a

                        ld a, c
                        add a, a
                        add a, a
                        add a, a

                        add 32                          ; y offset

                        ld l, a

                        pop af
                        ret

; Does not take offset into account
Pixel2Brick:
                        ld a, l
                        sub 32
                        ld l, a

                        srl h
                        srl h
                        srl h
                        srl h

                        srl l
                        srl l
                        srl l
                        ret

Brick2LevelMap:
                        ld de, LevelMap

                        ld a, l
                        add a, a
                        add a, a
                        add a, a
                        add a, a

                        add h

                        ld h, 0
                        ld l, a

                        add hl, de
                        ret

; Resets all the bricks in the level to on
ResetLevel:
                        push hl
                        ld hl, LevelMap                         ; point hl to the brick map
                        xor a                                 
                        ld b, 256                               ; 256 bytes for map (could use bits if short on mem)
ResetNextBrick                        
                        ld (hl), a                              ; mark brick inactive
                        inc hl                                  ; next brick
                        djnz ResetNextBrick
                        pop hl
                        ret

; LoadLevel - Loads the current level into the LevelMap
LoadLevel:
                        call LoadCurrentLevel
                        ld b, (ix)                                       ; brick count
                        ld a, b
                        ld (LevelBlockCount), a
                        ld c, 0

                        ld de, LevelMap
                        inc ix                                          ; Put ix after the level name
                        inc ix
                        inc ix

LoadNextBrick:
                        ld a, (ix)                                      ; check if ix is a colour command           
                        cp 255
                        jp z, SetBrickColour

                        ld h, 0
                        ld l, a
                        
                        add hl, de
                        ld (hl), c

                        inc ix
                        djnz LoadNextBrick
                        ret

SetBrickColour:
                        ld a, (ix + 1)
                        or 7
                        ld c, a
                        inc ix
                        inc ix
                        jr LoadNextBrick                             ; Don't count colour instructions
                                                                     ; towards the number of blocks so skip djnz

DisplayLevel:
                        ld de, 0x4760                                ; 0, 31
                        ld hl, LevelMap
                        ld iy, Brick_Data

                        call DrawHorizontalMaskRow                  ; draw the top of the outline

                        ld de, 0x4080                                   ; 0, 32

                        call DrawMaskedRow                          ; draw 15 rows
                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow

                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow

                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow

                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow

                        call ColourLevel
                        ret

; Update a level row. Need to draw the 8 pixels of the row and one above, and one below
; Inputs: - a the pixel of the brick row to be updated - 1
; Trashes: af, hl, de, iy
UpdateLevel:
                        ld h, 0
                        ld l, a

                        call scadd                      ; put screen address into de

                        ld a, l                         ; Check if this is the row before the first brick
                        cp 31
                        jr z, UpdateTopLine             ; if it is, jump

                        ld iy, Brick_Data + 14          ; the line before the row needs the 7th row of the brick sprite

                        sub 7                           ; move to the y pixel of the previous row
                        ld l, a
                        call Pixel2LevelMap             ; hl points to the first brick of the previous row

                        call DrawUpperDividerRow        ; draw the bottom row of the brick
                        call NextRow2                   ; move to next character row
                        jr UpdateLevel1

UpdateTopLine:
                        ld hl, LevelMap                 ; point hl to start of levelmap
                        call DrawHorizontalMaskRow      ; draw the top border
                        ld de, 0x4080                   ; 0, 32

UpdateLevel1:
                        ld iy, Brick_Data               ; point iy at start of brick data
                        call DrawMaskedRow              ; draw a whole row

                        call DrawLowerDividerRow        ; draw the top line of the next row

                        call ColourLevel                ; fill in the colour
                        ret

DrawMaskedRow:
                        push iy
                        call DrawLowerDividerRow        ; draw the first row of the brick
                        inc iy                          ; move to next row of sprite data
                        inc iy
                        inc d                           ; move to the next pixel row

                        call DrawHorizontalRow          ; draw the next 6 rows
                        inc iy
                        inc iy

                        inc d
                        call DrawHorizontalRow
                        inc iy
                        inc iy

                        inc d
                        call DrawHorizontalRow
                        inc iy
                        inc iy

                        inc d
                        call DrawHorizontalRow
                        inc iy
                        inc iy

                        inc d
                        call DrawHorizontalRow
                        inc iy
                        inc iy

                        inc d
                        call DrawHorizontalRow
                        inc iy
                        inc iy

                        inc d
                        call DrawUpperDividerRow            ; draw the bottom line
                        call NextRow2                       ; move de to the next char row
                        pop iy

                        ret

; Draw the top line of the border
DrawHorizontalMaskRow:
                        push de, hl

                        ld b, 16                                ; draw 16 bricks in the row

DrawHorizontalMaskRowStart:
                        ld a, (hl)                              ; check the current brick
                        cp 0
                        jr z, DrawHorizontalMaskRow1            ; empty, jump to draw empty

                        ld a, 255                               ; not empty, fill with 255

DrawHorizontalMaskRow1:
                        ld (de), a                              ; draw next two chars
                        inc de
                        ld (de), a
                        inc de

DrawHorizontalMaskRowNext:
                        inc hl                                  ; move to next brick
                        djnz DrawHorizontalMaskRowStart

                        pop hl, de
                        ret

; Draw a middle line of the brick
DrawHorizontalRow:
                        push de, hl

                        ld b, 16                                ; draw 16 bricks

DrawHorizontalRowStart:
                        ld ix, hl                               ; point ix to hl

                        ld a, (hl)                              ; check current brick
                        cp 0
                        jr nz, DrawHorizontalRow1               ; not empty, jump

                        ld a, (ix - 1)                          ; check previous brick
                        cp 0
                        jr z, DrawHorizontalRow2                ; previous brick is empty, skip drawing border

                        ld a, 128                               ; not empty, draw the right border of the previous brick 
DrawHorizontalRow2:
                        ld (de), a                              ; draw first half of space
                        inc de

                        ld a, (ix + 1)                          ; check the next brick
                        cp 0
                        jr z, DrawHorizontalRow3                ; empty, skip the border

                        ld a, 1                                 ; not empty, draw the left border of the next brick
DrawHorizontalRow3:
                        ld (de), a                              ; draw second half of space
                        inc de

                        jr DrawHorizontalRowNext                ; go to next brick

DrawHorizontalRow1:
                        ld a, (iy)                              ; current brick not empty, draw the brick sprite
                        ld (de), a
                        inc de

                        ld a, (iy + 1)
                        ld (de), a
                        inc de

DrawHorizontalRowNext:
                        inc hl                                  ; next brick
                        djnz DrawHorizontalRowStart

                        pop hl, de
                        ret

; Draw the bottom of the brick. Don't ask why it's called upper divider FIXME: RENAME IT
DrawUpperDividerRow:
                        push de

                        ld b, 16                                ; Draw 16 bricks

DrawUpperDividerRowStart:
                        ld ix, hl

                        ld a, (hl)                              ; Check current brick
                        cp 0
                        jr nz, DrawUpperDividerRow1             ; Not empty, jump

                        ld a, (ix + 16)                         ; Check the next row
                        cp 0
                        jr z, DrawUpperDividerRow2              ; empty, so jump to draw the space

                        ld a, 255                               ; draw the upper border of the next row
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        jr DrawUpperDividerRowNext              ; Next brick

DrawUpperDividerRow2:
                        ld a, (ix - 1)                          ; current brick is empty, does it need a border
                        cp 0
                        jr z, DrawUpperDividerRow21             ; previous is empty, skip drawing border

                        ld a, 128                               ; ight border of previous brick
DrawUpperDividerRow21:
                        ld (de), a                              ; draw first half of brick space
                        inc de

                        ld a, (ix + 1)                          ; check next brick
                        cp 0
                        jr z, DrawUpperDividerRow22             ; next is empty, skip drawing border

                        ld a, 1                                 ; left border of next brick

DrawUpperDividerRow22:
                        ld (de), a                              ; draw second half of the brick
                        inc de

                        jr DrawUpperDividerRowNext              ; next brick

DrawUpperDividerRow1:
                        ld a, (iy)                              ; current brick not empty, so draw sprite
                        ld (de), a
                        inc de

                        ld a, (iy + 1)
                        ld (de), a
                        inc de

DrawUpperDividerRowNext:                                        
                        inc hl
                        djnz DrawUpperDividerRowStart           ; move to the next brick

                        pop de
                        ret

; Draw the top line of the row // FIXME: Rename it to something less stupid
DrawLowerDividerRow:
                        push de, hl

                        ld b, 16                                ; draw row of 16 bricks

DrawLowerDividerRowStart:
                        ld ix, hl

                        ld a, (hl)                              ; Check current brick
                        cp 0
                        jr nz, DrawLowerDividerRow1             ; Not empty, jump

                        ld a, (ix - 16)                         ; empty so check the previous row
                        cp 0
                        jr z, DrawLowerDividerRow2              ; previous row empty so jump to skip drawing border

                        ld a, 255                               ; draw two chars of 255
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        jr DrawLowerDividerRowNext              ; next brick

DrawLowerDividerRow2:
                        ld a, (ix - 1)                          ; check previous brick
                        cp 0
                        jr z, DrawLowerDividerRow21             ; empty, skip drawing border

                        ld a, 128                               ; right border of previous brick
DrawLowerDividerRow21:
                        ld (de), a                              ; draw first half of space
                        inc de

                        ld a, (ix + 1)                          ; check next brick
                        cp 0
                        jr z, DrawLowerDividerRow22             ; empty, skip drawing border

                        ld a, 1                                 ; left hand border

DrawLowerDividerRow22:
                        ld (de), a                              ; draw second half of space
                        inc de

                        jr DrawLowerDividerRowNext              ; next brick

DrawLowerDividerRow1:
                        ld a, (iy)                              ; brick is not empty, draw sprite
                        ld (de), a
                        inc de

                        ld a, (iy + 1)
                        ld (de), a
                        inc de

DrawLowerDividerRowNext:
                        inc hl
                        djnz DrawLowerDividerRowStart           ; go to next brick

                        pop hl, de
                        ret

ColourLevel:
                        ld hl, LevelMap
                        ld de, 0x5880

                        ld bc, 255
ColourNextBlock:
                        ld a, (hl)
                        cp 0
                        jr nz, DontChangeColour
                        ld a, 56
DontChangeColour:
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        inc hl

                        djnz ColourNextBlock
                        ret

; CheckBrickCollision - Check if the ball has collided with any of the bricks
; Inputs: hl - x, y of the ball
; Outputs: z - set to indicate collision
CheckBrickCollision:
                        ld a, l
                        cp 23                                           ; y-offset
                        ret c

                        cp 168                                          ; bottom of possible bricks
                        ret nc

                        ld iy, LevelMap                                 ; point to the LevelMap
                        ld c, 32                                        ; y = 0

CheckRow:
                        ld b, 0                                         ; x = 0

CheckBrick:
                        ld a, (iy)
                        cp 0                                            ; Check an empty slot
                        jr z, CheckNextBrick

                        call CheckCollision8v16x8v8                     ; Check if the ball has entered the 8x8 

                        jr z, BrickCollision                            ; check the fine grained collisions
CheckNextBrick:
                        inc iy                                          ; move to the next brick

                        ld a, b
                        add 16
                        ld b, a
                        cp 256
                        jr nz, CheckBrick
                                                                        ; end of row
                        ld a, c                                         ; check not end of bricks
                        add 8
                        ld c, a
                        cp 160
                        jr nz, CheckRow

                        ret

; inputs: iy - the collision brick
;         bc - x,y of the colllision brick
;         hl - x,y of the ball
BrickCollision:
                        push bc
                        call CheckFineGrainCollision            ; check fine grained collision
                        pop bc

                        jr nz, CheckNextBrick                       ; check if we actually hit before removing brick

                        call RemoveBrick                        ; remove the brick

                        ret                                     ; ret here will stop checking any other bricks

CheckFineGrainCollision:
                                                                ; first check if the centre of the ball
                                                                ; on the y axis is between bounds of the brick

                        push bc

                        ld a, b                                 ; lower brick y in b
                        add 8                                   ; add 8
                        ld c, a                                 ; higher brick y in c

                        ld a, l                                 ; ball y in a
                        add 4                                   ; get centre of ball

                        call Between                            ; is centre of ball between the brick y?

                        pop bc
                        jr nz, CheckDirectionSwitch2            ; no? then check the x side

                        call Switch_XDir                        ; if ball y is between the brick y then
                        call Ball_HitX                          ; it hit on the side, so change x direction
                        cp a                                    ; set z to indicate a collision
                        ret                                     ; return because if can't hit anywhere else

CheckDirectionSwitch2:
                                                                ; next check if the centre of the ball
                                                                ; on the x axis is between the bounds of the brick
                        push bc

                        ld b, c                                 ; lower brick x in b
                        ld a, c                                 ; add 16
                        add 15
                        ld c, a                                 ; higher brick x in c

                        ld a, h                                 ; ball x in a
                        add 4                                   ; centre of the ball

                        call Between                            ; is between x bounds?
                        pop bc
                        jr nz, CheckInnerBox                    ; no? check the inner box

                        call Switch_YDir                        ; if ball x is between brick x then
                        call Ball_HitY                          ; it hit on the top or bottom
                                                                ; so switch y direction
                        cp a                                    ; set z to indicate a colision
                        ret                                     ; return because it can't hit anywhere else

CheckInnerBox:
                                                                ; inner box is the 6x6 box inside the 8x8
                        push hl
                        inc h
                        inc l

                        call CheckColllision6v16x6v8            ; check inner box
                        pop hl

                        ret nz                                  ; Didn't collide, so return

                        call Switch_YDir                        ; Hitting the inner box means it hit on the corner
                        call Switch_XDir                        ; so switch both directions
                        call Ball_HitY
                        call Ball_HitX

                        cp a                                    ; set z to indicate a collision happened

                        ret

; RemoveBrick - Remove the brick from the screen

RemoveBrick
                        ; bc: brick pixel x,y
                        ; iy: brick in levelmap
                        ; hl: ball x,y

                        xor a
                        ld (iy), a                              ; erase brick

                        ld a, c
                        dec a
                        ld (needsdisplay), a

                        call AddBrickScore

                        ld a, (bonusadder)                      ; increase the score bonus for every brick hit
                        inc a
                        ld (bonusadder), a

                        ld a, (LevelBlockCount)
                        dec a
                        ld (LevelBlockCount), a

                        ret