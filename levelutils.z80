; Points ix to the current level
LoadCurrentLevel:
                        push hl                                 ; store hl

                        ld h, 0                                 ; load the current level into hl
                        ld a, (currentlevel)
                        ld l, a
                        add hl, hl                              ; double it because we're accessing memory offsets

                        ld de, levels                           ; load the levels table
                        add hl, de                              ; point hl to the current level

                        ld a, (hl)                              ; get the address of the level in hl
                        inc hl
                        ld h, (hl)
                        ld l, a

                        ld ix, hl                               ; copy hl to ix

                        pop hl                                  ; restore
                        ret

; Inputs: hl: pixel coords (including offset)
; Outputs: hl: address of corresponding brick in level map
Pixel2LevelMap:
                        ld a, l
                        sub 32
                        ld l, a
                        ; fall thru to PixelNoOffset2LevelMap
PixelNoOffset2LevelMap:
                        ld de, LevelMap

                        srl h
                        srl h
                        srl h
                        srl h

                        ld a, l                             
                        add a
                        add h

                        ld h, 0
                        ld l, a

                        add hl, de
                        ret

; inputs b - brick x, c - brick y
; outputs: h - pixel x, l - pixel y
Brick2Pixel:
                        push af

                        ld a, b
                        add a, a
                        add a, a
                        add a, a
                        add a, a

                        ld h, a

                        ld a, c
                        add a, a
                        add a, a
                        add a, a

                        add 32                          ; y offset

                        ld l, a

                        pop af
                        ret

; Does not take offset into account
Pixel2Brick:
                        ld a, l
                        sub 32
                        ld l, a

                        srl h
                        srl h
                        srl h
                        srl h

                        srl l
                        srl l
                        srl l
                        ret

Brick2LevelMap:
                        ld de, LevelMap

                        ld a, l
                        add a, a
                        add a, a
                        add a, a
                        add a, a

                        add h

                        ld h, 0
                        ld l, a

                        add hl, de
                        ret

; Resets all the bricks in the level to on
ResetLevel:
                        push hl
                        ld hl, LevelMap                         ; point hl to the brick map
                        xor a                                 
                        ld b, 256                               ; 256 bytes for map (could use bits if short on mem)
ResetNextBrick                        
                        ld (hl), a                              ; mark brick inactive
                        inc hl                                  ; next brick
                        djnz ResetNextBrick
                        pop hl
                        ret

; LoadLevel - Loads the current level into the LevelMap
LoadLevel:
                        call LoadCurrentLevel
                        ld b, (ix)                                       ; brick count
                        ld a, b
                        ld (LevelBlockCount), a
                        ld c, 0

                        ld de, LevelMap
                        inc ix                                          ; Put ix after the level name
                        inc ix
                        inc ix

LoadNextBrick:
                        ld a, (ix)                                      ; check if ix is a colour command           
                        cp 255
                        jp z, SetBrickColour

                        ld h, 0
                        ld l, a
                        
                        add hl, de
                        ld (hl), c

                        inc ix
                        djnz LoadNextBrick
                        ret

SetBrickColour:
                        ld a, (ix + 1)
                        or 7
                        ld c, a
                        inc ix
                        inc ix
                        jr LoadNextBrick                             ; Don't count colour instructions
                                                                     ; towards the number of blocks so skip djnz

DisplayLevel:
                        push af, bc, de, hl, ix, iy

                        exx
                        ld bc, previous_row
                        ld hl, LevelMap
                        ld iy, LevelMap + 16
                        exx

                        ld ix, Brick_Data

                        ld de, 0x4060                                   ; screen address for row 24
                        ld hl, 0x4060

                        call DrawBrickRow
                        call DrawBrickRow
                        call DrawBrickRow
                        call DrawBrickRow

                        call DrawBrickRow
                        call DrawBrickRow
                        call DrawBrickRow
                        call DrawBrickRow

                        call DrawBrickRow
                        call DrawBrickRow
                        call DrawBrickRow
                        call DrawBrickRow

                        call DrawBrickRow
                        call DrawBrickRow
                        call DrawBrickRow
                        call DrawBrickRow

                        call ColourLevel
                        pop iy, ix, hl, de, bc, af
                        ret

DrawBrickRow:
                        push ix
                        call DrawRow0

                        ld de, hl
                        call NextRow2
                        ld hl, de

                        call DrawRow1to6
                        ld de, hl
                        call NextRow2
                        ld hl, de

                        call DrawRow1to6
                        ld de, hl
                        call NextRow2
                        ld hl, de

                        call DrawRow1to6
                        ld de, hl
                        call NextRow2
                        ld hl, de

                        call DrawRow1to6
                        ld de, hl
                        call NextRow2
                        ld hl, de

                        call DrawRow1to6
                        ld de, hl
                        call NextRow2
                        ld hl, de

                        call DrawRow1to6
                        ld de, hl
                        call NextRow2
                        ld hl, de

                        call DrawRow7

                        ld de, hl
                        call NextRow2
                        ld hl, de

                        pop ix
                        ret

DrawRow0:
                        exx
                        push bc, hl, iy
                        ld iyl, 0
                        exx

                        ld b, 16
DrawRow0Start:
                        exx

                        ld d, 0

                        ld a, (bc)
                        cp 0
                        jr z, DrawRow01
                        set 0, d

DrawRow01:
                        ld a, (hl)
                        cp 0
                        jr z, DrawRow02
                        set 1, d

DrawRow02:
                        inc bc

                        inc hl
                        ld a, (hl)
                        ld iyh, a
                        dec hl

                        ld a, d              
                        exx

                        ; a now has bits set
                        ; 0 - nothing
                        ; 1 - Draw 255
                        ; 2, 3 - Draw sprite
                        cp 2
                        jr c, DrawRow03

                        ld a, (ix)
                        ld (de), a
                        inc de
                        ld a, (ix + 1)
                        ld (de), a
                        inc de
                        jr DrawRow09

DrawRow03:
                        cp 0
                        jr z, DrawRow04

                        ld a, 255
                        ld (de), a
                        inc de
                        ld (de), a

                        inc de
                        jr DrawRow09

DrawRow04:
                        ld a, iyl
                        cp 0
                        jr z, DrawRow05

                        ld a, 128
                        jr DrawRow06
DrawRow05:
                        xor a
DrawRow06:
                        ld (de), a
                        inc de

                        ld a, iyh
                        cp 0
                        jr z, DrawRow07

                        ld a, 1
                        jr DrawRow08
DrawRow07:
                        xor a
DrawRow08:
                        ld (de), a
                        inc de

DrawRow09:
                        exx
                        ld a, (hl)
                        ld iyl, a
                        inc hl
                        exx
                        djnz DrawRow0Start

DrawRow0Finish:
                        exx
                        pop iy, hl, bc
                        exx

                        ret

DrawRow1to6:
                        inc ix
                        inc ix

                        ld b, 16

                        exx
                        push bc, hl, iy
                        ld b, 0
                        exx

DrawRow1to6Start:
                        exx

                        ld d, 0
                        ld a, b
                        cp 0
                        jr z, DrawRow1to62
                        set 2, d
DrawRow1to62:
                        ld a, (hl)
                        ld b, a
                        cp 0
                        inc hl
                        jr z, DrawRow1to63
                        set 1, d
                        jr DrawRow1to64
DrawRow1to63:
                        ld a, (hl)
                        cp 0
                        jr z, DrawRow1to64
                        set 0, d
DrawRow1to64:
                        ld a, d

                        exx

                        bit 1, a                                ; Check if drawing sprite
                        jr z, DrawRow1to61                     ; No, skip to empty

                        ld a, (ix)
                        ld (de), a

                        inc de
                        ld a, (ix + 1)
                        ld (de), a
                        jr DrawRow1to65                         ; Move to next block

DrawRow1to61:
                        bit 2, a                                ; Check if previous block present
                        jr z, DrawRow1to66                     ; No, draw empty space
                        ex af, af'

                        ld a, 128                               ; draw left line
                        ld (de), a

                        ex af, af'
                        jr DrawRow1to68                         ; skip over empty left

DrawRow1to66:
                        ex af, af'

                        xor a
                        ld (de), a

                        ex af, af'

DrawRow1to68:                        
                        inc de

                        bit 0, a
                        jr z, DrawRow1to67
                        ld a, 1
                        ld (de), a
                        jr DrawRow1to65

DrawRow1to67:
                        xor a
                        ld (de), a

DrawRow1to65:
                        inc de
                        djnz DrawRow1to6Start

                        exx
                        pop iy, hl, bc
                        exx

                        ret

DrawRow7:
                        exx
                        ld d, 0
                        exx

                        inc ix
                        inc ix

                        ld b, 16

DrawRow7Start:
                        exx

                        ld a, d
                        and 64
                        ld d, a

                        ld a, (iy)
                        cp 0
                        jr z, DrawRow71
                        set 0, d

DrawRow71:
                        ld a, (hl)
                        cp 0
                        jr z, DrawRow72
                        set 1, d

DrawRow72:
                        inc hl
                        ld a, (hl)
                        cp 0
                        jr z, DrawRow721
                        set 6, d
DrawRow721:
                        dec hl

                        inc iy

                        ld a, d              
                        exx

                        ; a now has bits set
                        ; 0 - nothing
                        ; 1 - Draw 255
                        ; 2, 3 - Draw sprite
                        cp 2
                        jr c, DrawRow73

                        ld a, (ix)
                        ld (de), a
                        inc de
                        ld a, (ix + 1)
                        ld (de), a

                        inc de
                        jr DrawRow75

DrawRow73:
                        cp 0
                        jr nz, DrawRow74

                        inc de
                        inc de
                        jr DrawRow75

DrawRow74:
                        ld a, 255
                        ld (de), a
                        inc de
                        ld (de), a

                        inc de
DrawRow75:
                        exx
                        ld a, (hl)
                        cp 0
                        jr z, DrawRow76
                        set 7, d
DrawRow76:
                        inc hl
                        exx
                        djnz DrawRow7Start

DrawRow7Finish:
                        ret

ColourLevel:
                        ld hl, LevelMap
                        ld de, 0x5860

                        ld bc, 255
ColourNextBlock:
                        ld a, (hl)
                        cp 0
                        jr nz, DontChangeColour
                        ld a, 56
DontChangeColour:
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        inc hl

                        djnz ColourNextBlock
                        ret

; CheckBrickCollision - Check if the ball has collided with any of the bricks
; Inputs: hl - x, y of the ball
; Outputs: z - set to indicate collision
CheckBrickCollision:
                        ld a, l
                        cp 23                                           ; y-offset
                        ret c

                        cp 168                                          ; bottom of possible bricks
                        ret nc

                        ld iy, LevelMap                                 ; point to the LevelMap
                        ld c, 0                                         ; y = 0

CheckRow:
                        ld b, 0                                         ; x = 0

CheckBrick:
                        ld a, (iy)
                        cp 0                                            ; Check an empty slot
                        jr z, CheckNextBrick

                        push bc                                         ; Store bc

                        push hl                                         ; store hl
                        call Brick2Pixel                                ; convert brick slot to pixel in hl
                        push hl                                         ; copy hl -> bc
                        pop bc

                        pop hl                                          ; restore hl

                        call CheckCollision8v16x8v8                     ; Check if the ball has entered the 8x8 
                        pop bc                                          ; restore the brick counters

                        jr z, BrickCollision                            ; check the fine grained collisions
CheckNextBrick:
                        inc iy                                          ; move to the next brick
                        inc b                                           ; next x

                        ld a, b
                        cp 16                                           ; check not end of row
                        jr nz, CheckBrick
                                                                        ; end of row
                        inc c                                           ; move to next row
                        ld a, c                                         ; check not end of bricks
                        cp 16
                        jr nz, CheckRow

                        ret

; inputs - iy set to the collision brick
BrickCollision:
                        push hl

                        call Brick2Pixel                                ; hl contains pixel x,y of brick

                        push bc
                        call CheckFineGrainCollision            ; check fine grained collision
                        pop bc
                        pop hl
                        
                        jr nz, CheckNextBrick                       ; check if we actually hit before removing brick

                        call RemoveBrick                        ; remove the brick

                        ret                                     ; ret here will stop checking any other bricks

CheckFineGrainCollision:
                                                                ; first check if the centre of the ball
                                                                ; on the y axis is between bounds of the brick

                        ld b, l                                 ; lower brick y in b
                        ld a, l                                 ; add 8
                        add 8
                        ld c, a                                 ; higher brick y in c

                        push ix
                        ld ix, spritetable
                        ld a, (ix+SPRITETABLE_Y)                ; ball y in a
                        pop ix
                        add 4                                   ; get centre of ball

                        call Between                            ; is centre of ball between the brick y?
                        jr nz, CheckDirectionSwitch2            ; no? then check the x side

                        call Switch_XDir                        ; if ball y is between the brick y then
                        call Ball_HitX                          ; it hit on the side, so change x direction
                        cp a                                    ; set z to indicate a collision
                        ret                                     ; return because if can't hit anywhere else

CheckDirectionSwitch2:
                                                                ; next check if the centre of the ball
                                                                ; on the x axis is between the bounds of the brick

                        ld b, h                                 ; lower brick x in b
                        ld a, h                                 ; add 16
                        add 15
                        ld c, a                                 ; higher brick x in c

                        push ix
                        ld ix, spritetable
                        ld a, (ix+SPRITETABLE_X)                          ; ball x in a
                        pop ix
                        add 4                                   ; centre of the ball

                        call Between                            ; is between x bounds?
                        jr nz, CheckInnerBox                    ; no? check the inner box

                        call Switch_YDir                        ; if ball x is between brick x then
                        call Ball_HitY                          ; it hit on the top or bottom
                                                                ; so switch y direction
                        cp a                                    ; set z to indicate a colision
                        ret                                     ; return because it can't hit anywhere else

CheckInnerBox:
                                                                ; inner box is the 6x6 box inside the 8x8
                        push ix
                        ld ix, spritetable
                        ld b, (ix+SPRITETABLE_X)
                        ld c, (ix+SPRITETABLE_Y)
                        pop ix
                        inc b                                   ; inset the hit box
                        inc c

                        call CheckColllision6v16x6v8            ; check inner box
                        ret nz                                  ; Didn't collide, so return

                        call Switch_YDir                        ; Hitting the inner box means it hit on the corner
                        call Switch_XDir                        ; so switch both directions
                        call Ball_HitY
                        call Ball_HitX

                        cp a                                    ; set z to indicate a collision happened

                        ret

; RemoveBrick - Remove the brick from the screen

RemoveBrick
                        ; bc: brick x,y
                        ; iy: brick in levelmap
                        ; hl: ball x,y

                        push hl                                 ; Store hl cos stuff trashes it

                        call Brick2Pixel                        ; hl now has brick pixel x,y

                        xor a
                        ld (iy), a                              ; erase brick

                        ld a, 1
                        ld (needsdisplay), a

                        pop hl

                        call AddBrickScore

                        ld a, (bonusadder)                      ; increase the score bonus for every brick hit
                        inc a
                        ld (bonusadder), a

                        ld a, (LevelBlockCount)
                        dec a
                        ld (LevelBlockCount), a

                        ret