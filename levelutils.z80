; Points ix to the current level
LoadCurrentLevel:
                        push hl                                 ; store hl

                        ld h, 0                                 ; load the current level into hl
                        ld a, (currentlevel)
                        ld l, a
                        add hl, hl                              ; double it because we're accessing memory offsets

                        ld de, levels                           ; load the levels table
                        add hl, de                              ; point hl to the current level

                        ld a, (hl)                              ; get the address of the level in hl
                        inc hl
                        ld h, (hl)
                        ld l, a

                        ld ix, hl                               ; copy hl to ix

                        pop hl                                  ; restore
                        ret

; Inputs: hl: pixel coords (including offset)
; Outputs: hl: address of corresponding brick in level map
Pixel2LevelMap:
                        ld a, l
                        sub 32
                        ld l, a
                        ; fall thru to PixelNoOffset2LevelMap
PixelNoOffset2LevelMap:
                        ld de, LevelMap

                        srl h
                        srl h
                        srl h
                        srl h

                        ld a, l                             
                        add a
                        add h

                        ld h, 0
                        ld l, a

                        add hl, de
                        ret

; inputs b - brick x, c - brick y
; outputs: h - pixel x, l - pixel y
Brick2Pixel:
                        push af

                        ld a, b
                        add a, a
                        add a, a
                        add a, a
                        add a, a

                        ld h, a

                        ld a, c
                        add a, a
                        add a, a
                        add a, a

                        add 32                          ; y offset

                        ld l, a

                        pop af
                        ret

; Does not take offset into account
Pixel2Brick:
                        ld a, l
                        sub 32
                        ld l, a

                        srl h
                        srl h
                        srl h
                        srl h

                        srl l
                        srl l
                        srl l
                        ret

Brick2LevelMap:
                        ld de, LevelMap

                        ld a, l
                        add a, a
                        add a, a
                        add a, a
                        add a, a

                        add h

                        ld h, 0
                        ld l, a

                        add hl, de
                        ret

; Resets all the bricks in the level to on
ResetLevel:
                        push hl
                        ld hl, LevelMap                         ; point hl to the brick map
                        xor a                                 
                        ld b, 256                               ; 256 bytes for map (could use bits if short on mem)
ResetNextBrick                        
                        ld (hl), a                              ; mark brick inactive
                        inc hl                                  ; next brick
                        djnz ResetNextBrick
                        pop hl
                        ret

; LoadLevel - Loads the current level into the LevelMap
LoadLevel:
                        call LoadCurrentLevel
                        ld b, (ix)                                       ; brick count
                        ld a, b
                        ld (LevelBlockCount), a
                        ld c, 0

                        ld de, LevelMap
                        inc ix                                          ; Put ix after the level name
                        inc ix
                        inc ix

LoadNextBrick:
                        ld a, (ix)                                      ; check if ix is a colour command           
                        cp 255
                        jp z, SetBrickColour

                        ld h, 0
                        ld l, a
                        
                        add hl, de
                        ld (hl), c

                        inc ix
                        djnz LoadNextBrick
                        ret

SetBrickColour:
                        ld a, (ix + 1)
                        or 7
                        ld c, a
                        inc ix
                        inc ix
                        jr LoadNextBrick                             ; Don't count colour instructions
                                                                     ; towards the number of blocks so skip djnz

DisplayLevel:
                        ld iy, LevelMap
                        ld c, 0

DisplayNextRow:
                        ld b, 0

DisplayNextBrick:
                        ld a, (iy)
                        cp 0
                        jr z, MoveToNextBrick

                        call DrawBrick

MoveToNextBrick:
                        inc iy
                        inc b
                        ld a, b
                        cp 16
                        jr nz, DisplayNextBrick

                        inc c
                        ld a, c
                        cp 16
                        jr nz, DisplayNextRow

                        ret

; Draw Brick - draws the brick and any required border
; inputs - a: brick colour
;         iy: points to the brick in the LevelMap
;          b: x in brick space
;          c: y in brick space
DrawBrick:
                        call Brick2Pixel                                ; hl points to the pixel x,y

                        call pixelattradd                               ; Set the attributes
                        ld (de), a
                        inc de
                        ld (de), a
                        call scadd                                      ; de points to the screen address

                        call DrawBrickSprite

                        call CheckAboveBrick
                        call z, DrawAboveLine

                        call CheckBelowBrick
                        call z, DrawBelowLine

                        call CheckLeftBrick
                        call z, DrawRightLine

                        call CheckRightBrick
                        call z, DrawLeftLine

                        ret

; EraseBrick - Removes the brick and adjusts the border appropriately
; inputs - iy: points to the brick in the LevelMap
;           b: x in brick space
;           c: y in brick space
;           h: x in pixel space
;           l: y in pixel space
EraseBrick:
                        call pixelattradd                       ; get the attr address for the brick

                        ld a, 56                                ; 56 is white paper, black ink
                        ld (de), a                              ; put it into the two adjacent character spaces
                        inc de
                        ld (de), a

                        call scadd                              ; get the screen address for the pixel

                        push ix
                        call DrawBrickSprite
                        pop ix

                        ; ex af, af'
                        ; xor a
                        ; ex af, af'

                        ; call CheckAboveBrick
                        ; call z, SetAboveBrick

                        ; call CheckBelowBrick
                        ; call z, SetBelowBrick

                        ; call CheckLeftBrick
                        ; call z, SetLeftBrick

                        ; call CheckRightBrick
                        ; call z, SetRightBrick

                        ; ex af, af'

                        ; ex af, af'

                        call CheckAboveBrick
                        call z, EraseAboveLine
                        call nz, DrawInnerAboveLine

                        call CheckBelowBrick
                        call z, EraseBelowLine
                        call nz, DrawInnerBelowLine

                        ld a, b
                        cp 0
                        call nz, MaybeCheckLeftBrick

                        ld a, b
                        cp 15
                        call nz, MaybeCheckRightBrick

                        ret

MaybeCheckLeftBrick:
                        call CheckLeftBrick
                        call z, EraseLeftLine
                        call nz, DrawInnerLeftLine
                        ret

MaybeCheckRightBrick:
                        call CheckRightBrick
                        call z, EraseRightLine
                        call nz, DrawInnerRightLine
                        ret

SetAboveBrick:
                        ex af, af'
                        set 0, a
                        ex af, af'

                        ret

SetBelowBrick:
                        ex af, af'
                        set 1, a
                        ex af, af'

                        ret

SetLeftBrick:
                        ex af, af'
                        set 2, a
                        ex af, af'

                        ret

SetRightBrick:
                        ex af, af'
                        set 3, a
                        ex af, af'

                        ret

CheckAboveBrick:
                        ld a, c
                        cp 0
                        ret z

                        ld de, 16
                        push hl

                        push iy
                        pop hl
                        
                        sbc hl, de

                        push hl
                        pop iy

                        pop hl

                        ld a, (iy)

                        cp 0

                        add iy, de
                        ret
                        
DrawAboveLine:
                        push af
                        push hl

                        dec l
                        call scadd
                        ld a, 255
                        ld (de), a
                        inc de
                        ld (de), a

                        pop hl
                        pop af
                        ret

DrawInnerAboveLine:
                        push hl

                        call scadd

                        ld a, 255
                        ld (de), a

                        inc de
                        ld (de), a

                        pop hl
                        ret

EraseAboveLine:
                        push af
                        push hl

                        dec l
                        call scadd
                        ld a, 0
                        ld (de), a
                        inc de
                        ld (de), a

                        pop hl
                        pop af
                        ret

CheckBelowBrick:
                        ld a, c
                        cp 15
                        ret z

                        ld de, 16

                        add iy, de
                        ld a, (iy)

                        push hl

                        push iy
                        pop hl

                        sbc hl, de

                        push hl
                        pop iy

                        pop hl

                        cp 0
                        ret
                        
DrawBelowLine:
                        push af
                        push hl
                        ld a, l
                        add 8
                        ld l, a
                        call scadd
                        ld a, 255
                        ld (de), a
                        inc de
                        ld (de), a

                        pop hl
                        pop af
                        ret

DrawInnerBelowLine:
                        push hl

                        ld a, l
                        add 7
                        ld l, a
                        call scadd

                        ld a, 255
                        ld (de), a

                        inc de
                        ld (de), a

                        pop hl
                        ret

EraseBelowLine:
                        push af
                        push hl

                        ld a, l
                        add 8
                        ld l, a
                        call scadd

                        ld a, 0
                        ld (de), a
                        inc de
                        ld (de), a

                        pop hl
                        pop af
                        ret

ClearZAndReturn:
                        or 1                                    ; Clear z
                        ret

CheckLeftBrick:
                        ld a, b
                        cp 0
                        jr z, ClearZAndReturn

                        dec iy
                        ld a, (iy)
                        cp 0

                        inc iy

                        ret
                        
DrawRightLine:
                        push hl

                        dec h
                        call scadd

                        ld a, 1
                        call DrawVerticalLine8
                        pop hl

                        ret

DrawInnerRightLine:
                        push hl

                        ld a, h
                        add 8
                        ld h, a

                        call scadd

                        ld a, 1
                        call DrawVerticalLine8
                        pop hl

                        ret

EraseRightLine:
                        push af
                        push hl

                        ld a, h
                        add 16
                        ld h, a
                        call scadd

                        ld a, 128
                        call EraseVerticalLine8

                        pop hl
                        pop af
                        ret

CheckRightBrick:
                        ld a, b
                        cp 15
                        jr z, ClearZAndReturn

                        inc iy
                        ld a, (iy)
                        cp 0

                        dec iy

                        ret
                        
DrawLeftLine:
                        push hl

                        ld a, h
                        add 16
                        ld h, a

                        call scadd

                        ld a, 128
                        call DrawVerticalLine8
                        pop hl

                        ret

DrawInnerLeftLine:
                        push hl

                        call scadd

                        ld a, 128
                        call DrawVerticalLine8
                        pop hl

                        ret

EraseLeftLine:
                        push af
                        push hl

                        dec h
                        call scadd

                        ld a, 1
                        call EraseVerticalLine8

                        pop hl
                        pop af
                        ret

; CheckBrickCollision - Check if the ball has collided with any of the bricks
; Inputs: hl - x, y of the ball
; Outputs: z - set to indicate collision
CheckBrickCollision:
                        ld a, l
                        cp 23                                           ; y-offset
                        ret c

                        cp 168                                          ; bottom of possible bricks
                        ret nc

                        ld iy, LevelMap                                 ; point to the LevelMap
                        ld c, 0                                         ; y = 0

CheckRow:
                        ld b, 0                                         ; x = 0

CheckBrick:
                        ld a, (iy)
                        cp 0                                            ; Check an empty slot
                        jr z, CheckNextBrick

                        push bc                                         ; Store bc

                        push hl                                         ; store hl
                        call Brick2Pixel                                ; convert brick slot to pixel in hl
                        push hl                                         ; copy hl -> bc
                        pop bc

                        pop hl                                          ; restore hl

                        call CheckCollision8v16x8v8                     ; Check if the ball has entered the 8x8 
                        pop bc                                          ; restore the brick counters

                        jr z, BrickCollision                            ; check the fine grained collisions
CheckNextBrick:
                        inc iy                                          ; move to the next brick
                        inc b                                           ; next x

                        ld a, b
                        cp 16                                           ; check not end of row
                        jr nz, CheckBrick
                                                                        ; end of row
                        inc c                                           ; move to next row
                        ld a, c                                         ; check not end of bricks
                        cp 16
                        jr nz, CheckRow

                        ret

; inputs - iy set to the collision brick
BrickCollision:
                        push hl

                        call Brick2Pixel                                ; hl contains pixel x,y of brick

                        push bc
                        call CheckFineGrainCollision            ; check fine grained collision
                        pop bc
                        pop hl
                        
                        jr nz, CheckNextBrick                       ; check if we actually hit before removing brick

                        call RemoveBrick                        ; remove the brick

                        ret                                     ; ret here will stop checking any other bricks

CheckFineGrainCollision:
                                                                ; first check if the centre of the ball
                                                                ; on the y axis is between bounds of the brick

                        ld b, l                                 ; lower brick y in b
                        ld a, l                                 ; add 8
                        add 8
                        ld c, a                                 ; higher brick y in c

                        push ix
                        ld ix, spritetable
                        ld a, (ix+SPRITETABLE_Y)                ; ball y in a
                        pop ix
                        add 4                                   ; get centre of ball

                        call Between                            ; is centre of ball between the brick y?
                        jr nz, CheckDirectionSwitch2            ; no? then check the x side

                        call Switch_XDir                        ; if ball y is between the brick y then
                        call Ball_HitX                          ; it hit on the side, so change x direction
                        cp a                                    ; set z to indicate a collision
                        ret                                     ; return because if can't hit anywhere else

CheckDirectionSwitch2:
                                                                ; next check if the centre of the ball
                                                                ; on the x axis is between the bounds of the brick

                        ld b, h                                 ; lower brick x in b
                        ld a, h                                 ; add 16
                        add 15
                        ld c, a                                 ; higher brick x in c

                        push ix
                        ld ix, spritetable
                        ld a, (ix+SPRITETABLE_X)                          ; ball x in a
                        pop ix
                        add 4                                   ; centre of the ball

                        call Between                            ; is between x bounds?
                        jr nz, CheckInnerBox                    ; no? check the inner box

                        call Switch_YDir                        ; if ball x is between brick x then
                        call Ball_HitY                          ; it hit on the top or bottom
                                                                ; so switch y direction
                        cp a                                    ; set z to indicate a colision
                        ret                                     ; return because it can't hit anywhere else

CheckInnerBox:
                                                                ; inner box is the 6x6 box inside the 8x8
                        push ix
                        ld ix, spritetable
                        ld b, (ix+SPRITETABLE_X)
                        ld c, (ix+SPRITETABLE_Y)
                        pop ix
                        inc b                                   ; inset the hit box
                        inc c

                        call CheckColllision6v16x6v8            ; check inner box
                        ret nz                                  ; Didn't collide, so return

                        call Switch_YDir                        ; Hitting the inner box means it hit on the corner
                        call Switch_XDir                        ; so switch both directions
                        call Ball_HitY
                        call Ball_HitX

                        cp a                                    ; set z to indicate a collision happened

                        ret

; RemoveBrick - Remove the brick from the screen

RemoveBrick
                        ; bc: brick x,y
                        ; iy: brick in levelmap
                        ; hl: ball x,y

                        push hl                                 ; Store hl cos stuff trashes it

                        call Brick2Pixel                        ; hl now has brick pixel x,y

                        xor a
                        ld (iy), a                              ; erase brick

                        call EraseBrick

                        pop hl

                        call AddBrickScore

                        ld a, (bonusadder)                      ; increase the score bonus for every brick hit
                        inc a
                        ld (bonusadder), a

                        ld a, (LevelBlockCount)
                        dec a
                        ld (LevelBlockCount), a

                        ret

EraseBorderDone:
                        ret

Erase0:
                        ; Erase all borders
                        ; No Inner border

                        dec l
                        ex af, af'
                        ld a, l                                 ; Load y into a' for nextrow
                        ex af, af'

                        dec l                                   ; previous row to delete the border
                        call scadd                              ; screen address

                        xor a                                   ; a to 0

                        ld (de), a                              ; erase the top border
                        inc de
                        ld (de), a
                        dec de
                        
                        ld b, 8
E0NextRow:
                        ex af, af'
                        call nextrow                            ; next row
                        ex af, af'

                        dec de                                  ; erase left border
                        ld a, (de)
                        ld c, 1
                        xor c
                        ld (de), a

                        xor a                                   ; erase the brick
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        ld a, (de)                              ; erase right border
                        ld c, 128
                        xor c
                        ld (de), a

                        dec de
                        dec de

                        djnz E0NextRow

                        ex af, af'
                        call nextrow
                        ex af, af'

                        xor a                                   ; erase bottom border
                        ld (de), a
                        inc de
                        ld (de), a

                        jp EraseBorderDone


Erase1:
                        ; Erase left, right, bottom borders
                        ; Draw top line
                        ex af, af'
                        ld a, l
                        ex af, af'
                        
                        call scadd

                        dec de
                        ld a, (de)
                        ld c, 1
                        xor c
                        ld (de), a

                        inc de
                        ld a, 255
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        ld a, (de)
                        ld c, 128
                        xor c
                        ld (de), a
                        dec de
                        dec de
                        dec de

                        ld b, 7
E1NextRow:
                        dec de                                  ; erase left border
                        ld a, (de)
                        ld c, 1
                        xor c
                        ld (de), a

                        xor a
                        inc de                                  ; erase brick
                        ld (de), a              
                        inc de
                        ld (de), a

                        inc de                                  ; erase right border
                        ld a, (de)
                        ld c, 128
                        xor c
                        ld (de), a

                        dec de
                        dec de

                        ex af, af'
                        call nextrow
                        ex af, af'

                        djnz E1NextRow

                        xor a                                   ; erase bottom border
                        ld (de), a
                        inc de
                        ld (de), a

                        jp EraseBorderDone

Erase2:
                        ; Erase left, right, top borders
                        ; Draw bottom line
                        dec l
                        ex af, af'
                        ld a, l
                        ex af, af'
                        
                        call scadd

                        ld a, 255
                        ld (de), a
                        inc a
                        ld (de), a
                        dec de

                        ex af, af'
                        call nextrow
                        ex af, af'

                        ld b, 7
E2NextRow:
                        dec de                                  ; erase left border
                        ld a, (de)
                        ld c, 1
                        xor c
                        ld (de), a

                        xor a
                        inc de                                  ; erase brick
                        ld (de), a              
                        inc de
                        ld (de), a

                        inc de                                  ; erase right border
                        ld a, (de)
                        ld c, 128
                        xor c
                        ld (de), a

                        dec de
                        dec de

                        ex af, af'
                        call nextrow
                        ex af, af'

                        djnz E2NextRow

                        ld 1, 255
                        ld (de), a
                        inc de
                        ld (de), a

                        jp EraseBorderDone

Erase3:
                        ; erase l&r
                        ; draw t&b
                        jp EraseBorderDone

Erase4:
                        ; erase t, b, r
                        ; draw l
                        jp EraseBorderDone

Erase5:
                        ; erase b, r
                        ; draw l, r
                        jp EraseBorderDone

Erase6:
                        ; erase t, r
                        ; draw l, b
                        jp EraseBorderDone

Erase7:
                        ; erase r
                        ; draw t, l, b
                        jp EraseBorderDone

Erase8:
                        ; erase t, l, b
                        ; draw r
                        jp EraseBorderDone

Erase9:
                        ; erase l, b
                        ; draw t, r
                        jp EraseBorderDone

Erase10:
                        ; erase l, t
                        ; draw r, b
                        jp EraseBorderDone

Erase11:
                        ; erase l
                        ; draw t, r, b
                        jp EraseBorderDone

Erase12:
                        ; erase t, b
                        ; draw l, r
                        jp EraseBorderDone

Erase13:
                        ; erase b
                        ; draw l, t , r

                        ex af, af'
                        ld a, l
                        ex af, af'
                        
                        call scadd

                        ld a, 255
                        ld (de), a
                        inc a
                        ld (de), a
                        dec de

                        ex af, af'
                        call nextrow
                        ex af, af'

                        ld b, 7
E13NextRow:
                        ld a, 128
                        ld (de), a

                        inc de                                  ; erase brick
                        ld (de), a              

                        dec de

                        ex af, af'
                        call nextrow
                        ex af, af'

                        djnz E13NextRow

                        ld 1, 255
                        ld (de), a
                        inc de
                        ld (de), a

                        jp EraseBorderDone

Erase14:
                        ; erase t
                        ; draw l, b, r
                        jp EraseBorderDone

Erase15:
                        ; Empty by design
                        jp EraseBorderDone