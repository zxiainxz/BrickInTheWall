; Points ix to the current level
LoadCurrentLevel:
                        push hl                                 ; store hl

                        ld h, 0                                 ; load the current level into hl
                        ld a, (currentlevel)
                        ld l, a
                        add hl, hl                              ; double it because we're accessing memory offsets

                        ld de, levels                           ; load the levels table
                        add hl, de                              ; point hl to the current level

                        ld a, (hl)                              ; get the address of the level in hl
                        inc hl
                        ld h, (hl)
                        ld l, a

                        ld ix, hl                               ; copy hl to ix

                        pop hl                                  ; restore
                        ret

; Inputs: hl: pixel coords (including offset)
; Outputs: hl: address of corresponding brick in level map
Pixel2LevelMap:
                        ld a, l
                        sub 32
                        ld l, a
                        ; fall thru to PixelNoOffset2LevelMap
PixelNoOffset2LevelMap:
                        ld de, LevelMap

                        srl h
                        srl h
                        srl h
                        srl h

                        ld a, l                             
                        add a
                        add h

                        ld h, 0
                        ld l, a

                        add hl, de
                        ret

; inputs b - brick x, c - brick y
; outputs: h - pixel x, l - pixel y
Brick2Pixel:
                        ld a, b
                        add a, a
                        add a, a
                        add a, a
                        add a, a

                        ld h, a

                        ld a, c
                        add a, a
                        add a, a
                        add a, a

                        add 32                          ; y offset

                        ld l, a
                        ret

; Does not take offset into account
Pixel2Brick:
                        srl h
                        srl h
                        srl h
                        srl h

                        srl l
                        srl l
                        srl l
                        ret

Brick2LevelMap:
                        ld de, LevelMap

                        ld a, l
                        add a, a
                        add a, a
                        add a, a
                        add a, a

                        add h

                        ld h, 0
                        ld l, a

                        add hl, de
                        ret

; Resets all the bricks in the level to on
ResetLevel:
                        push hl
                        ld hl, LevelMap                         ; point hl to the brick map
                        xor a                                 
                        ld b, 256                               ; 256 bytes for map (could use bits if short on mem)
ResetNextBrick                        
                        ld (hl), a                              ; mark brick inactive
                        inc hl                                  ; next brick
                        djnz ResetNextBrick
                        pop hl
                        ret

; DispalyLevel - Displays the level stored in LevelMap
DisplayLevel:
                        call LoadCurrentLevel
                        ld b, (ix)                                       ; brick count
                        ld a, b
                        ld (LevelBlockCount), a
                        ld c, 0
                        inc ix                                          ; Put ix after the level name
                        inc ix
                        inc ix

DisplayNextBrick:
                        ld a, (ix)                                      ; check if ix is a colour command           
                        cp 255
                        jp z, SetBrickColour

                        ld hl, (ix)
                        ld a, l
                        add 32
                        ld l, a
                        call scadd

                        push ix
                        push hl
                        call DrawBrickSprite
                        pop hl
                        pop ix

                        call pixelattradd
                        ld a, c                                         ; put the colour into the attrs
                        ld (de), a
                        inc de
                        ld (de), a

                        push hl

                        call Pixel2LevelMap

                        ld a, 1
                        ld (hl), a

                        pop hl

                        inc ix
                        inc ix

                        djnz DisplayNextBrick

                        call GenerateOutline
                        call DrawOutline
                        ret

SetBrickColour:
                        ld a, (ix + 1)
                        or 7
                        ld c, a
                        inc ix
                        inc ix
                        jr DisplayNextBrick                             ; Don't count colour instructions
                                                                        ; towards the number of blocks so skip djnz

; 76543210
; 000ablrc
GenerateOutline:
                        ld hl, LevelMap
                        call GOProcessFirstRow

                        ld b, 14
GOPR:                   call GOProcessRow
                        djnz GOPR

                        call GOProcessLastRow
                        ret

GOProcessFirstRow:
                        ld a, (hl)
                        cp 0
                        jr z, GOPFRCheckMiddle

                        ; process first brick

                        or 4
                        ld (hl), a
                        push hl
                        call GOProcessRightBrick
                        pop hl

                        push hl
                        call GOProcessBelowBrick
                        pop hl

GOPFRCheckMiddle:
                        inc hl
                        ld b, 14

GOPFirstRowMiddle:
                        ld a, (hl)
                        cp 0
                        jr z, GOPFRMiddleNext

                        ld (hl), a

                        push hl
                        call GOProcessLeftBrick
                        pop hl

                        push hl
                        call GOProcessRightBrick
                        pop hl

                        push hl
                        call GOProcessBelowBrick
                        pop hl

GOPFRMiddleNext:
                        inc hl
                        djnz GOPFirstRowMiddle

                        ld a, (hl)
                        cp 0
                        jr z, GOFRDone

                        or 2
                        ld (hl), a

                        ; process last brick
                        push hl
                        call GOProcessLeftBrick
                        pop hl

                        push hl
                        call GOProcessBelowBrick
                        pop hl

GOFRDone:
                        inc hl

                        ret

GOProcessRow:
                        ld a, (hl)
                        cp 0
                        jr z, GOPRCheckMiddle

                        or 4
                        ld (hl), a

                        push hl
                        call GOProcessRightBrick
                        pop hl

                        push hl
                        call GOProcessAboveBrick
                        pop hl

                        push hl
                        call GOProcessBelowBrick
                        pop hl

GOPRCheckMiddle:
                        inc hl

                        push bc

                        ld b, 14

GOPRowMiddle:
                        ld a, (hl)
                        cp 0
                        jr z, GOPRNext

                        push hl
                        call GOProcessLeftBrick
                        pop hl

                        push hl
                        call GOProcessRightBrick
                        pop hl

                        push hl
                        call GOProcessAboveBrick
                        pop hl

                        push hl
                        call GOProcessBelowBrick
                        pop hl
GOPRNext:
                        inc hl
                        djnz GOPRowMiddle

                        pop bc

                        ld a, (hl)
                        cp 0
                        jr z, GOPRDone

                        or 2
                        ld (hl), a

                        ; process last brick
                        push hl
                        call GOProcessLeftBrick
                        pop hl

                        push hl
                        call GOProcessAboveBrick
                        pop hl

                        push hl
                        call GOProcessBelowBrick
                        pop hl
GOPRDone:
                        inc hl
                        ret

GOProcessLastRow:
                        ld a, (hl)
                        cp 0
                        jr z, GOPLRMiddle

                        or 4
                        ld (hl), a

                        push hl
                        call GOProcessRightBrick
                        pop hl

                        push hl
                        call GOProcessAboveBrick
                        pop hl
GOPLRMiddle:
                        inc hl

                        ld b, 14

GOPLastRowMiddle:
                        ld a, (hl)
                        cp 0
                        jr z, GOPLRNext

                        ld (hl), a

                        push hl
                        call GOProcessLeftBrick
                        pop hl

                        push hl
                        call GOProcessRightBrick
                        pop hl

                        push hl
                        call GOProcessAboveBrick
                        pop hl

GOPLRNext:
                        inc hl
                        djnz GOPLastRowMiddle

                        ld a, (hl)
                        cp 0
                        ret z

                        or 2
                        ld (hl), a

                        ; process last brick
                        push hl
                        call GOProcessLeftBrick
                        pop hl

                        push hl
                        call GOProcessAboveBrick
                        pop hl

                        ret

; There must be some self-modifying code that could set the bit number this code doesn't need duplicated
GOProcessLeftBrick:
                        dec hl
                        ld a, (hl)
                        cp 0
                        ret z
                        set 1, a
                        ld (hl), a
                        ret

GOProcessRightBrick:
                        inc hl
                        ld a, (hl)
                        cp 0
                        ret z
                        set 2, a
                        ld (hl), a
                        ret

GOProcessAboveBrick:
                        ld de, 16
                        sbc hl, de

                        ld a, (hl)
                        cp 0
                        ret z
                        set 3, a
                        ld (hl), a
                        ret

GOProcessBelowBrick:
                        ld de, 16
                        add hl, de
                        ld a, (hl)
                        cp 0
                        ret z
                        set 4, a
                        ld (hl), a
                        ret

DrawOutline:
                        ld c, 0
                        ld hl, LevelMap

DODrawRow:
                        ld b, 0

DODrawNextBrick:
                        ld a, (hl)
                        cp 0
                        jr z, DOMoveToNextBrick

                        call DrawBrickOutline

DOMoveToNextBrick:
                        inc hl

                        inc b
                        ld a, b
                        cp 16
                        jr nz, DODrawNextBrick

                        inc c
                        ld a, c
                        cp 16
                        jr nz, DODrawRow

                        ret

DrawBrickOutline:

                        bit 1, a
                        call z, DODrawRightEdge

                        bit 2, a
                        call z, DODrawLeftEdge

                        bit 3, a
                        call z, DODrawBottomEdge

                        bit 4, a
                        call z, DODrawTopEdge

                        ret

DODrawRightEdge:
                        push hl

                        inc b
                        call Brick2Pixel
                        dec b

                        call scadd

                        push bc

                        ld a, 128
                        call DrawVerticalLine

                        pop bc
                        pop hl
                        ret

DODrawLeftEdge:
                        push hl

                        call Brick2Pixel
                        dec h

                        call scadd

                        push bc
                        
                        ld a, 1
                        call DrawVerticalLine

                        pop bc
                        pop hl

                        ret

DrawVerticalLine:
                        ld b, 8

                        ex af, af'
                        ld a, l
                        ex af, af'
DrawNextVertical:       
                        push bc
                        ld c, a
                        ld a, (de)
                        or c                 
                        ld (de), a
                        pop bc
                        
                        ex af, af'
                        call nextrow
                        ex af, af'

                        djnz DrawNextVertical
                        ret

DODrawBottomEdge:
                        push hl

                        inc c
                        call Brick2Pixel
                        dec c

                        call scadd

                        ld a, 255
                        ld (de), a
                        inc de
                        ld (de), a

                        pop hl
                        ret

DODrawTopEdge:
                        push hl

                        call Brick2Pixel

                        dec l

                        call scadd

                        ld a, 255
                        ld (de), a
                        inc de
                        ld (de), a

                        pop hl
                        ret

; CheckBrickCollision - Check if the ball has collided with any of the bricks
; Inputs: hl - x, y of the ball
; Outputs: z - set to indicate collision
CheckBrickCollision:
                        push ix                                         ; store ix because LoadCurrentLevel will destroy
                        call LoadCurrentLevel
                        push ix                                         ; copy ix to iy
                        pop iy
                        pop ix                                          ; restore original ix

                        ld a, l
                        cp 23                                           ; y-offset
                        ret c

                        cp 168                                          ; bottom of possible bricks
                        ret nc

                        ld b, (iy)                                      ; number of bricks
                        inc iy                                          ; start of block data
                        inc iy
                        inc iy

CheckBrick:
                        ld a, (iy)                                      ;
                        cp 255                                          ; is it a colour instruction?
                        jr z, SkipColour                                ; skip colour instruction

                        ; push bc                                         ; store the brick counter
                        ; ld bc, (iy)
                        ; push hl

                        ; push bc
                        ; pop hl
                        push hl
                        ld hl, (iy)
                        call PixelNoOffset2LevelMap
                        ld a, (hl)
                        and 1

                        pop hl

                        jr z, CheckNextBrick

                        push bc
                        ld bc, (iy)
                        ld a, c
                        add 32
                        ld c, a
                        call CheckCollision8v16x8v8                     ; Check if the ball has entered the 8x8 
                        pop bc                                          ; restore the brick count

                        jr z, BrickCollision                            ; check the fine grained collisions
CheckNextBrick:
                        inc iy                                          ; move to the next brick struct
                        inc iy

                        djnz CheckBrick                                 ; check next brick
                        ret

SkipColour:
                        inc iy
                        inc iy
                        jr CheckBrick

; inputs - iy set to the collision brick
BrickCollision:
                        push hl
                        ld hl, (iy)

                        push bc
                        call CheckFineGrainCollision            ; check fine grained collision
                        pop bc
                        pop hl
                        
                        jr nz, CheckNextBrick                       ; check if we actually hit before removing brick

                        call RemoveBrick                        ; remove the brick

                        ret                                     ; ret here will stop checking any other bricks

CheckFineGrainCollision:
                                                                ; first check if the centre of the ball
                                                                ; on the y axis is between bounds of the brick

                        ld b, l                                 ; lower brick y in b
                        ld a, l                                 ; add 8
                        add 8
                        ld c, a                                 ; higher brick y in c

                        push ix
                        ld ix, spritetable
                        ld a, (ix+SPRITETABLE_Y)                ; ball y in a
                        pop ix
                        add 4                                   ; get centre of ball

                        call Between                            ; is centre of ball between the brick y?
                        jr nz, CheckDirectionSwitch2            ; no? then check the x side

                        call Switch_XDir                        ; if ball y is between the brick y then
                        call Ball_HitX                          ; it hit on the side, so change x direction
                        cp a                                    ; set z to indicate a collision
                        ret                                     ; return because if can't hit anywhere else

CheckDirectionSwitch2:
                                                                ; next check if the centre of the ball
                                                                ; on the x axis is between the bounds of the brick

                        ld b, h                                 ; lower brick x in b
                        ld a, h                                 ; add 16
                        add 15
                        ld c, a                                 ; higher brick x in c

                        push ix
                        ld ix, spritetable
                        ld a, (ix+SPRITETABLE_X)                          ; ball x in a
                        pop ix
                        add 4                                   ; centre of the ball

                        call Between                            ; is between x bounds?
                        jr nz, CheckInnerBox                    ; no? check the inner box

                        call Switch_YDir                        ; if ball x is between brick x then
                        call Ball_HitY                          ; it hit on the top or bottom
                                                                ; so switch y direction
                        cp a                                    ; set z to indicate a colision
                        ret                                     ; return because it can't hit anywhere else

CheckInnerBox:
                                                                ; inner box is the 6x6 box inside the 8x8
                        push ix
                        ld ix, spritetable
                        ld b, (ix+SPRITETABLE_X)
                        ld c, (ix+SPRITETABLE_Y)
                        pop ix
                        inc b                                   ; inset the hit box
                        inc c

                        call CheckColllision6v16x6v8            ; check inner box
                        ret nz                                  ; Didn't collide, so return

                        call Switch_YDir                        ; Hitting the inner box means it hit on the corner
                        call Switch_XDir                        ; so switch both directions
                        call Ball_HitY
                        call Ball_HitX

                        cp a                                    ; set z to indicate a collision happened

                        ret

; RemoveBrick - Remove the brick from the screen
; Inputs: h - x coord of the brick
;         l - y coord of the brick
;         ix - index to brick structure
RemoveBrick
                        push hl                                 ; Store hl cos stuff trashes it

                        ; FIXME: At some point before calling remove brick
                        ; hl has the ball coords
                        ld hl, (iy)

                        push hl

                        call PixelNoOffset2LevelMap
                        xor a
                        ld (hl), a

                        pop hl

                        ld a, l
                        add 32
                        ld l, a

                        call pixelattradd                       ; get the attr address for the brick

                        ld a, 56                                ; 56 is white paper
                        ld (de), a                              ; put it into the two adjacent character spaces
                        inc e
                        ld (de), a

                        call scadd                              ; get the screen address for the pixel

                        push ix
                        push hl
                        call DrawBrickSprite                    ; Draw the brick over the old brick to remove it
                        pop hl
                        call UpdateOutline
                        pop ix
                        pop hl

                        call AddBrickScore

                        ld a, (bonusadder)                      ; increase the score bonus for every brick hit
                        inc a
                        ld (bonusadder), a

                        ld a, (LevelBlockCount)
                        dec a
                        ld (LevelBlockCount), a
                        ret

; Update the outline for the block at pixel h,l
UpdateOutline:
                        push bc

                        push hl
                        ld a, l
                        sub 32
                        ld l, a
                        call Pixel2Brick

                        push hl
                        pop bc

                        ld a, h
                        cp 0

                        push hl
                        call nz, RemoveProcessLeftBrick
                        pop hl

                        cp 15

                        push hl
                        call nz, RemoveProcessRightBrick
                        pop hl

                        ld a, l
                        cp 0
                        
                        push hl
                        call nz, RemoveProcessAboveBrick
                        pop hl

                        cp 15

                        push hl
                        call nz, RemoveProcessBelowBrick
                        pop hl

                        pop hl
                        pop bc
                        ret

RemoveProcessLeftBrick:
                        call Brick2LevelMap

                        dec hl
                        ld a, (hl)
                        cp 0
                        ret z
                        res 1, a
                        ld (hl), a

                        dec b

                        call DrawBrickOutline

                        inc b
                        ret

RemoveProcessRightBrick:
                        call Brick2LevelMap

                        inc hl
                        ld a, (hl)
                        cp 0
                        ret z
                        res 2, a
                        ld (hl), a

                        inc b

                        call DrawBrickOutline

                        dec b
                        ret

RemoveProcessAboveBrick:
                        call Brick2LevelMap

                        ld de, 16
                        sbc hl, de

                        ld a, (hl)
                        cp 0
                        ret z
                        res 3, a
                        ld (hl), a

                        dec c

                        call DrawBrickOutline

                        inc c
                        ret

RemoveProcessBelowBrick:
                        call Brick2LevelMap

                        ld de, 16
                        add hl, de
                        ld a, (hl)
                        cp 0
                        ret z
                        res 4, a
                        ld (hl), a

                        inc c

                        call DrawBrickOutline

                        dec c
                        ret