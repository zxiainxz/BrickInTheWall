; Points ix to the current level
LoadCurrentLevel:
                        push hl                                 ; store hl

                        ld h, 0                                 ; load the current level into hl
                        ld a, (currentlevel)
                        ld l, a
                        add hl, hl                              ; double it because we're accessing memory offsets

                        ld de, levels                           ; load the levels table
                        add hl, de                              ; point hl to the current level

                        ld a, (hl)                              ; get the address of the level in hl
                        inc hl
                        ld h, (hl)
                        ld l, a

                        ld ix, hl                               ; copy hl to ix

                        pop hl                                  ; restore
                        ret

; Inputs: hl: pixel coords (including offset)
; Outputs: hl: address of corresponding brick in level map
Pixel2LevelMap:
                        ld a, l
                        sub 32
                        ld l, a
                        ; fall thru to PixelNoOffset2LevelMap
PixelNoOffset2LevelMap:
                        push de

                        ld de, LevelMap

                        srl h
                        srl h
                        srl h
                        srl h

                        ld a, l                             
                        add a
                        add h

                        ld h, 0
                        ld l, a

                        add hl, de

                        pop de
                        ret

; inputs b - brick x, c - brick y
; outputs: h - pixel x, l - pixel y
Brick2Pixel:
                        push af

                        ld a, b
                        add a, a
                        add a, a
                        add a, a
                        add a, a

                        ld h, a

                        ld a, c
                        add a, a
                        add a, a
                        add a, a

                        add 32                          ; y offset

                        ld l, a

                        pop af
                        ret

; Does not take offset into account
Pixel2Brick:
                        ld a, l
                        sub 32
                        ld l, a

                        srl h
                        srl h
                        srl h
                        srl h

                        srl l
                        srl l
                        srl l
                        ret

Brick2LevelMap:
                        ld de, LevelMap

                        ld a, l
                        add a, a
                        add a, a
                        add a, a
                        add a, a

                        add h

                        ld h, 0
                        ld l, a

                        add hl, de
                        ret

; Resets all the bricks in the level to on
ResetLevel:
                        push hl
                        ld hl, LevelMap                         ; point hl to the brick map
                        xor a                                 
                        ld b, 256                               ; 256 bytes for map (could use bits if short on mem)
ResetNextBrick                        
                        ld (hl), a                              ; mark brick inactive
                        inc hl                                  ; next brick
                        djnz ResetNextBrick
                        pop hl
                        ret

; LoadLevel - Loads the current level into the LevelMap
LoadLevel:
                        call LoadCurrentLevel
                        ld b, (ix)                                       ; brick count
                        ld a, b
                        ld (LevelBlockCount), a
                        ld c, 0

                        ld de, LevelMap
                        inc ix                                          ; Put ix after the level name
                        inc ix
                        inc ix

LoadNextBrick:
                        ld a, (ix)                                      ; check if ix is a colour command           
                        cp 255
                        jp z, SetBrickColour

                        ld h, 0
                        ld l, a
                        
                        add hl, de
                        ld (hl), c

                        inc ix
                        djnz LoadNextBrick
                        ret

SetBrickColour:
                        ld a, (ix + 1)
                        or 7
                        ld c, a
                        inc ix
                        inc ix
                        jr LoadNextBrick                             ; Don't count colour instructions
                                                                     ; towards the number of blocks so skip djnz

DisplayLevel:
                        ld de, 0x4760                                ; 0, 31
                        ld hl, LevelMap
                        ld iy, Brick_Data

                        call DrawHorizontalMaskRow

                        ld de, 0x4080                                   ; 0, 32

                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow

                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow

                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow

                        call DrawMaskedRow
                        call DrawMaskedRow
                        call DrawMaskedRow

                        call ColourLevel
                        ret

UpdateLevel:
                        ld h, 0
                        ld l, a

                        call scadd

                        ld a, l
                        cp 31
                        jr z, UpdateTopLine

                        ld iy, Brick_Data + 14

                        sub 7
                        ld l, a
                        call Pixel2LevelMap

                        call DrawUpperDividerRow
                        call NextRow2
                        jr UpdateLevel1

UpdateTopLine:
                        ld hl, LevelMap
                        call DrawHorizontalMaskRow
                        ld de, 0x4080                                   ; 0, 32

UpdateLevel1:
                        ld iy, Brick_Data
                        call DrawMaskedRow

                        call DrawLowerDividerRow

                        call ColourLevel
                        ret

DrawMaskedRow:
                        push iy
                        call DrawLowerDividerRow
                        inc iy
                        inc iy
                        inc d

                        call DrawHorizontalRow
                        inc iy
                        inc iy

                        inc d
                        call DrawHorizontalRow
                        inc iy
                        inc iy

                        inc d
                        call DrawHorizontalRow
                        inc iy
                        inc iy

                        inc d
                        call DrawHorizontalRow
                        inc iy
                        inc iy

                        inc d
                        call DrawHorizontalRow
                        inc iy
                        inc iy

                        inc d
                        call DrawHorizontalRow
                        inc iy
                        inc iy

                        inc d
                        call DrawUpperDividerRow
                        call NextRow2
                        pop iy

                        ret

DrawHorizontalMaskRow:
                        push de, hl

                        ld b, 16

DrawHorizontalMaskRowStart:
                        ld a, (hl)
                        cp 0
                        jr z, DrawHorizontalMaskRow1

                        ld a, 255
                        jr DrawHorizontalMaskRow2
DrawHorizontalMaskRow1:
                        xor a
DrawHorizontalMaskRow2:

                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

DrawHorizontalMaskRowNext:
                        inc hl
                        djnz DrawHorizontalMaskRowStart

                        pop hl, de
                        ret

DrawHorizontalRow:
                        push de, hl

                        ld b, 16

DrawHorizontalRowStart:
                        ld ix, hl

                        ld a, (hl)
                        cp 0
                        jr nz, DrawHorizontalRow1

                        ld a, (ix - 1)
                        cp 0
                        jr z, DrawHorizontalRow2

                        ld a, 128
DrawHorizontalRow2:
                        ld (de), a
                        inc de

                        ld a, (ix + 1)
                        cp 0
                        jr z, DrawHorizontalRow3

                        ld a, 1
DrawHorizontalRow3:
                        ld (de), a
                        inc de

                        jr DrawHorizontalRowNext

DrawHorizontalRow1:
                        ld a, (iy)
                        ld (de), a
                        inc de                                  ; current brick not empty

                        ld a, (iy + 1)
                        ld (de), a
                        inc de

DrawHorizontalRowNext:
                        inc hl
                        djnz DrawHorizontalRowStart

                        pop hl, de
                        ret

DrawUpperDividerRow:
                        push de

                        ld b, 16

DrawUpperDividerRowStart:
                        ld ix, hl

                        ld a, (hl)                              ; Check current brick
                        cp 0
                        jr nz, DrawUpperDividerRow1             ; Not empty, jump

                        ld a, (ix + 16)
                        cp 0
                        jr z, DrawUpperDividerRow2

                        ld a, 255
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        jr DrawUpperDividerRowNext

DrawUpperDividerRow2:
                        ld a, (ix - 1)
                        cp 0
                        jr z, DrawUpperDividerRow21

                        ld a, 128
DrawUpperDividerRow21:
                        ld (de), a
                        inc de

                        ld a, (ix + 1)
                        cp 0
                        jr z, DrawUpperDividerRow22

                        ld a, 1

DrawUpperDividerRow22:
                        ld (de), a
                        inc de

                        jr DrawUpperDividerRowNext

DrawUpperDividerRow1:
                        ld a, (iy)
                        ld (de), a
                        inc de

                        ld a, (iy + 1)
                        ld (de), a
                        inc de

                        ld (de), a

DrawUpperDividerRowNext:
                        inc hl
                        djnz DrawUpperDividerRowStart

                        pop de
                        ret

DrawLowerDividerRow:
                        push de, hl

                        ld b, 16

DrawLowerDividerRowStart:
                        ld ix, hl

                        ld a, (hl)                              ; Check current brick
                        cp 0
                        jr nz, DrawLowerDividerRow1             ; Not empty, jump

                        ld a, (ix - 16)
                        cp 0
                        jr z, DrawLowerDividerRow2

                        ld a, 255
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        jr DrawLowerDividerRowNext

DrawLowerDividerRow2:
                        ld a, (ix - 1)
                        cp 0
                        jr z, DrawLowerDividerRow21

                        ld a, 128
DrawLowerDividerRow21:
                        ld (de), a
                        inc de

                        ld a, (ix + 1)
                        cp 0
                        jr z, DrawLowerDividerRow22

                        ld a, 1

DrawLowerDividerRow22:
                        ld (de), a
                        inc de

                        jr DrawLowerDividerRowNext

DrawLowerDividerRow1:
                        ld a, (iy)
                        ld (de), a
                        inc de

                        ld a, (iy + 1)
                        ld (de), a
                        inc de

                        ld (de), a

DrawLowerDividerRowNext:
                        inc hl
                        djnz DrawLowerDividerRowStart

                        pop hl, de
                        ret

ColourLevel:
                        ld hl, LevelMap
                        ld de, 0x5880

                        ld bc, 255
ColourNextBlock:
                        ld a, (hl)
                        cp 0
                        jr nz, DontChangeColour
                        ld a, 56
DontChangeColour:
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        inc hl

                        djnz ColourNextBlock
                        ret

; CheckBrickCollision - Check if the ball has collided with any of the bricks
; Inputs: hl - x, y of the ball
; Outputs: z - set to indicate collision
CheckBrickCollision:
                        ld a, l
                        cp 23                                           ; y-offset
                        ret c

                        cp 168                                          ; bottom of possible bricks
                        ret nc

                        ld iy, LevelMap                                 ; point to the LevelMap
                        ld c, 0                                         ; y = 0

CheckRow:
                        ld b, 0                                         ; x = 0

CheckBrick:
                        ld a, (iy)
                        cp 0                                            ; Check an empty slot
                        jr z, CheckNextBrick

                        push bc                                         ; Store bc

                        push hl                                         ; store hl
                        call Brick2Pixel                                ; convert brick slot to pixel in hl
                        push hl                                         ; copy hl -> bc
                        pop bc

                        pop hl                                          ; restore hl

                        call CheckCollision8v16x8v8                     ; Check if the ball has entered the 8x8 
                        pop bc                                          ; restore the brick counters

                        jr z, BrickCollision                            ; check the fine grained collisions
CheckNextBrick:
                        inc iy                                          ; move to the next brick
                        inc b                                           ; next x

                        ld a, b
                        cp 16                                           ; check not end of row
                        jr nz, CheckBrick
                                                                        ; end of row
                        inc c                                           ; move to next row
                        ld a, c                                         ; check not end of bricks
                        cp 16
                        jr nz, CheckRow

                        ret

; inputs - iy set to the collision brick
BrickCollision:
                        push hl

                        call Brick2Pixel                                ; hl contains pixel x,y of brick

                        push bc
                        call CheckFineGrainCollision            ; check fine grained collision
                        pop bc
                        pop hl
                        
                        jr nz, CheckNextBrick                       ; check if we actually hit before removing brick

                        call RemoveBrick                        ; remove the brick

                        ret                                     ; ret here will stop checking any other bricks

CheckFineGrainCollision:
                                                                ; first check if the centre of the ball
                                                                ; on the y axis is between bounds of the brick

                        ld b, l                                 ; lower brick y in b
                        ld a, l                                 ; add 8
                        add 8
                        ld c, a                                 ; higher brick y in c

                        push ix
                        ld ix, spritetable
                        ld a, (ix+SPRITETABLE_Y)                ; ball y in a
                        pop ix
                        add 4                                   ; get centre of ball

                        call Between                            ; is centre of ball between the brick y?
                        jr nz, CheckDirectionSwitch2            ; no? then check the x side

                        call Switch_XDir                        ; if ball y is between the brick y then
                        call Ball_HitX                          ; it hit on the side, so change x direction
                        cp a                                    ; set z to indicate a collision
                        ret                                     ; return because if can't hit anywhere else

CheckDirectionSwitch2:
                                                                ; next check if the centre of the ball
                                                                ; on the x axis is between the bounds of the brick

                        ld b, h                                 ; lower brick x in b
                        ld a, h                                 ; add 16
                        add 15
                        ld c, a                                 ; higher brick x in c

                        push ix
                        ld ix, spritetable
                        ld a, (ix+SPRITETABLE_X)                          ; ball x in a
                        pop ix
                        add 4                                   ; centre of the ball

                        call Between                            ; is between x bounds?
                        jr nz, CheckInnerBox                    ; no? check the inner box

                        call Switch_YDir                        ; if ball x is between brick x then
                        call Ball_HitY                          ; it hit on the top or bottom
                                                                ; so switch y direction
                        cp a                                    ; set z to indicate a colision
                        ret                                     ; return because it can't hit anywhere else

CheckInnerBox:
                                                                ; inner box is the 6x6 box inside the 8x8
                        push ix
                        ld ix, spritetable
                        ld b, (ix+SPRITETABLE_X)
                        ld c, (ix+SPRITETABLE_Y)
                        pop ix
                        inc b                                   ; inset the hit box
                        inc c

                        call CheckColllision6v16x6v8            ; check inner box
                        ret nz                                  ; Didn't collide, so return

                        call Switch_YDir                        ; Hitting the inner box means it hit on the corner
                        call Switch_XDir                        ; so switch both directions
                        call Ball_HitY
                        call Ball_HitX

                        cp a                                    ; set z to indicate a collision happened

                        ret

; RemoveBrick - Remove the brick from the screen

RemoveBrick
                        ; bc: brick x,y
                        ; iy: brick in levelmap
                        ; hl: ball x,y

                        push hl                                 ; Store hl cos stuff trashes it

                        call Brick2Pixel                        ; hl now has brick pixel x,y

                        xor a
                        ld (iy), a                              ; erase brick

                        ld a, l
                        dec a
                        ld (needsdisplay), a

                        pop hl

                        call AddBrickScore

                        ld a, (bonusadder)                      ; increase the score bonus for every brick hit
                        inc a
                        ld (bonusadder), a

                        ld a, (LevelBlockCount)
                        dec a
                        ld (LevelBlockCount), a

                        ret

ClearWholeRow:
                        push de
                        xor a
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de

                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a
                        inc de
                        ld (de), a

                        pop de
                        ret
