; GenerateLevel - Generate a basic 16x4 level
GenerateLevel
                        ld ix, LevelMap                                 ; index LevelMap
                        ld de, RowColours

                        ld a, NUMBER_BRICKS_PER_ROW * NUMBER_ROWS
                        ld (LevelBlockCount), a
                        
                        ld b, NUMBER_ROWS                               ; 4 rows
                        ld l, ROW_START                                       ; initial y coord is 24
GenerateNextRow
                        ld a, NUMBER_BRICKS_PER_ROW                            ; 16 bricks per row
                        ld h, 0                                         ; initial x coord is 0

GenerateNextBlock
                        ld (ix), hl                                     ; store x,y for this brick

                        ex af, af'                                      ; switch to shadow a' to save the counter

                        push hl
                        push de
                        pop hl

                        ld a, (hl)
                        ld (ix+2), a                                    ; store the brick colour (0 for no brick)
                        pop hl

                        ld a, h                                         ; add 16 to h
                        add 16
                        ld h, a
                        ex af, af'                                      ; switch back to brick count in a

                        dec a                                           ; decrease numbers bricks left in the row

                        push de
                        ld de, 3                                        
                        add ix, de                                      ; move to next brick struct
                        pop de

                        cp 0                                            ; check if a is 0
                        jr z, MoveToNextRow                             ; go to next row if it is
                        jr GenerateNextBlock                            ; otherwise next brick

MoveToNextRow
                        ld a, l                                         ; add 8 pixels to the row
                        add 8
                        ld l, a
                        inc e
                        djnz GenerateNextRow                            ; make next row if there is one
                        ret

; DispalyLevel - Displays the level stored in LevelMap
DisplayLevel:
                        ld ix, LevelMap                                 ; index LevelMap
                        ld b, NUMBER_BRICKS                                        ; brick count

DisplayNextBrick:
                        ld l, (ix)                                      ; y in l
                        ld h, (ix + 1)                                  ; x in h
                        call scadd                                      ; calculate screen addr for h,l
                                                                        ; de contains screen address
                        push ix                                         ; store ix, hl
                        push hl                                         ; should move to DrawBrickSprite
                        call DrawBrickSprite                            ; Draw the brick
                        pop hl
                        pop ix

                        call pixelattradd                               ; get attr address for h,l in de
                        ld a, (ix+2)                                    ; brick colour in a        
                        ld (de), a                                      ; put the colour in two attrs
                        inc de                                          
                        ld (de), a

                        ld de, 3                                        ; next brick struct
                        add ix, de
                        djnz DisplayNextBrick                           ; display next brick if it exists
                        ret

; CheckBrickCollision - Check if the ball has collided with any of the bricks
; Inputs: hl - x, y of the ball
; Outputs: z - set to indicate collision
CheckBrickCollision:
                        ld iy, LevelMap                                 ; Index LevelMap
                        ld b, NUMBER_BRICKS                                        ; number of bricks

CheckBrick:
                        ld a, (iy + 2)                                  ; load brick colour to a
                        cp 0                                            ; is it 0
                        jr z, CheckNextBrick                            ; skip missing brick

                        push bc                                         ; store the brick counter
                                                                        ; ld bc isn't working correctly (FIXME: Why?)
                        ld c, (iy)                                      ; y in c
                        ld b, (iy + 1)                                  ; x in b

                        call CheckCollision8v16x8v8                     ; Check if the ball has entered the 8x8 
                        pop bc                                          ; restore the brick count

                        jr z, BrickCollision                            ; check the fine grained collisions
CheckNextBrick:
                        ld de, 3                                        ; move to the next brick struct
                        add iy, de

                        djnz CheckBrick                                 ; check next brick
                        ret

; inputs - iy set to the collision brick
BrickCollision:
                        push hl
                        ld l, (iy)                              ; collided brick x,y in hl
                        ld h, (iy + 1)

                        push bc
                        call CheckFineGrainCollision            ; check fine grained collision
                        pop bc
                        pop hl
                        
                        jr nz, CheckNextBrick                       ; check if we actually hit before removing brick

                        call RemoveBrick                        ; remove the brick

                        ret                                     ; ret here will stop checking any other bricks

CheckFineGrainCollision:
                                                                ; first check if the centre of the ball
                                                                ; on the y axis is between bounds of the brick

                        ld b, l                                 ; lower brick y in b
                        ld a, l                                 ; add 8
                        add 8
                        ld c, a                                 ; higher brick y in c

                        push ix
                        ld ix, spritetable
                        ld a, (ix+SPRITETABLE_Y)                          ; ball y in a
                        pop ix
                        add 4                                   ; get centre of ball

                        call Between                            ; is centre of ball between the brick y?
                        jr nz, CheckDirectionSwitch2            ; no? then check the x side

                        call Switch_XDir                        ; if ball y is between the brick y then
                        call Ball_HitX                          ; it hit on the side, so change x direction
                        cp a                                    ; set z to indicate a collision
                        ret                                     ; return because if can't hit anywhere else

CheckDirectionSwitch2:
                                                                ; next check if the centre of the ball
                                                                ; on the x axis is between the bounds of the brick

                        ld b, h                                 ; lower brick x in b
                        ld a, h                                 ; add 16
                        add 15
                        ld c, a                                 ; higher brick x in c

                        push ix
                        ld ix, spritetable
                        ld a, (ix+SPRITETABLE_X)                          ; ball x in a
                        pop ix
                        add 4                                   ; centre of the ball

                        call Between                            ; is between x bounds?
                        jr nz, CheckInnerBox                    ; no? check the inner box

                        call Switch_YDir                        ; if ball x is between brick x then
                        call Ball_HitY                          ; it hit on the top or bottom
                                                                ; so switch y direction
                        cp a                                    ; set z to indicate a colision
                        ret                                     ; return because it can't hit anywhere else

CheckInnerBox:
                                                                ; inner box is the 6x6 box inside the 8x8
                        push ix
                        ld ix, spritetable
                        ld b, (ix+SPRITETABLE_X)
                        ld c, (ix+SPRITETABLE_Y)
                        pop ix
                        inc b                                   ; inset the hit box
                        inc c

                        call CheckColllision6v16x6v8            ; check inner box
                        ret nz                                  ; Didn't collide, so return

                        call Switch_YDir                        ; Hitting the inner box means it hit on the corner
                        call Switch_XDir                        ; so switch both directions
                        call Ball_HitY
                        call Ball_HitX

                        cp a                                    ; set z to indicate a collision happened

                        ret

; RemoveBrick - Remove the brick from the screen
; Inputs: h - x coord of the brick
;         l - y coord of the brick
;         ix - index to brick structure
RemoveBrick
                        push hl                                 ; Store hl cos stuff trashes it
                        ld hl, (iy)
                        xor a                                   ; zero a
                        ld (iy+2), a                            ; set the colour of the brick to 0
                                                                ; to indicate that it's missing

                        call pixelattradd                       ; get the attr address for the brick
                        ld a, 56                                ; 56 is white paper
                        ld (de), a                              ; put it into the two adjacent character spaces
                        inc e
                        ld (de), a

                        call scadd                              ; get the screen address for the pixel

                        push ix
                        call DrawBrickSprite                    ; Draw the brick over the old brick to remove it
                        pop ix
                        pop hl

                        ld a, (LevelBlockCount)
                        dec a
                        ld (LevelBlockCount), a
                        ret