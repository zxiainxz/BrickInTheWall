GameLoopInitialise:
                        xor a
                        ld (gameinit), a
                        ld hl, lives
                        ld (hl), INITIAL_LIVES                          ; set initial lives

                        call StartLevel

                        ld bc, score_string
                        ld hl, 0x0000
                        call DisplayString
                        call DrawScore

                        ld bc, lives_string
                        ld hl, 0xA300
                        call DisplayString
                        call DrawLives

                        call LoadSprites                                ; Put the sprites this scene uses into the
                                                                        ; sprite table

                        ld a, 1
                        ld (gameinit), a

                        jp InitialiseFinished

MainGameLoop:
                        halt

                        jr GameLoopDraw

GameLoopDrawFinished:

                        jp GameLoopLogic

GameLoopLogicFinished:

                        ld a, (LevelBlockCount)
                        and a
                        jp z, LevelComplete

                        ld a, (lives)
                        and a
                        jr z, GameOver

                        jr MainGameLoop

GameOver:
                        xor a
                        ld (gameinit), a
                        ld (currentlevel), a                    ; reset the level

                        ld a, GAMEOVER_SCENE                    ; Show the game over scene
                        ld (currentloop), a
                        jp SwitchMainLoop

; Loop through the bricks that need updated redrawing the space as appropriate
GameLoopDraw:
                        push ix
                        ld ix, UpdateBricks
                        ld b, 5
GLDrawNextBrick:
                        ld a, (ix+1)
                        and a
                        jp z, GLDrawFinished

                        ld de, (ix+UPDATEBRICKS_ADDR)
                        ld hl, (ix+UPDATEBRICKS_SPRITE)

                        call DrawBrick

                        ld de, (ix+UPDATEBRICKS_ATTRADDR)
                        ld a, 56
                        ld (de), a
                        inc de
                        ld (de), a

                        ld (ix+UPDATEBRICKS_ADDR), 0x00
                        ld (ix+UPDATEBRICKS_ADDR+1), 0x00
                        ld de, UPDATEBRICKS_SIZE
                        add ix, de

                        djnz GLDrawNextBrick

GLDrawFinished:
                        ld (GLDrawLoopStack+1), sp

                        ld a, (ClearCellCount)
                        and a
                        jr z, GLClearCellFinished

                        ld b, a
                        ld hl, ClearCellList
                        ld sp, hl

GLEraseCell:
                        pop hl
                        pop de

                        ; ld (hl), e
                        ld h, d

                        xor a

                        dup 3
                        pop de
                        ld (hl), e
                        inc h
                        ld (hl), d
                        inc h
                        edup

                        pop de
                        ld (hl), e
                        inc h
                        ld (hl), d

                        djnz GLEraseCell


GLClearCellFinished:
                        ld a, (DrawCellCount)
                        and a
                        jr z, GLDrawLoopFinished

                        ld b, a
                        ld hl, DrawCellList

                        ld sp, hl

GLDrawCell:
                        pop hl
                        pop de

                        ; ld (hl), e
                        ld h, d

                        dup 3
                        pop de
                        ld (hl), e
                        inc h
                        ld (hl), d
                        inc h
                        edup

                        pop de
                        ld (hl), e
                        inc h
                        ld (hl), d

                        djnz GLDrawCell

GLDrawLoopFinished:
GLDrawLoopStack:        ld sp, 0
                        ld hl, DrawCellList
                        ld (DrawCellListNext), hl

                        pop ix

                        call ClearCells
                        jp GameLoopDrawFinished

GameLoopLogic:
                        ld a, (gameinit)
                        and a
                        jp z, GameLoopLogicFinished

                        call ProposeBallMove                            ; proposed ball coordinates in hl

                        ld ix, spritetable

                        call CheckLoseBall
                        jp z, LoseLife

                        call CheckBatCollision

                        call CheckBrickCollision

                        call CheckYEdgeCollision
                        call CheckXEdgeCollision

                        call ReadKeys
                        call UpdateBatPosition
                        call CommitBatPosition

                        call DrawVelocity

                        call CommitBallMove
                        call CommitBallPosition

                        jp GameLoopLogicFinished

LoseLife
                        call ResetBallBat
                        jp GameLoopLogicFinished

LevelComplete:
                        xor a
                        ld (gameinit), a

                        ld a, (currentlevel)
                        inc a
                        ld (currentlevel), a

                        ld a, LEVELCOMPLETE_SCENE
                        ld (currentloop), a
                        jp SwitchMainLoop

StartLevel:
                        xor a                                           ; Stationary ball to start
                        ld (yballdir), a
                        ld (xballdir), a

                        call FadeScreenToWhite
                        call ResetLevel
                        call LoadLevel

                        call DisplayLevel

                        ret

ResetBallBat:
                        ld ix, spritetable

                        ld hl, INITIAL_BALL_COORDS
                        call UpdateSpriteXY
                        ld (proposedbally), hl

                        ld de, SPRITETABLE_SIZE
                        add ix, de

                        ld hl, (ix+SPRITETABLE_Y)
                        ld a, INITIAL_BAT_X
                        ld h, a
                        call UpdateSpriteXY

                        ld hl, NULL
                        ld (yballdir), hl
                        ret

DrawLives:
                        ld a, (lives)
                        and a
                        ret z

                        ld b, a
                        ld hl, 0xCD00
DrawLife:                        
                        call scadd
                        push hl, de

                        ld de, bat16x8Data
                        ld a, h

                        push af

                        and 7

                        ld h, 0
                        ld l, a

                        add hl, hl
                        
                        add hl, de
                        ld a, (hl)
                        inc hl
                        ld h, (hl)
                        ld l, a

                        pop af
                        pop de

                        di
                        call DrawSprite16x8PreShiftCharRow
                        ei
                        pop hl

                        ld d, 17
                        ld e, 0
                        add hl, de

                        djnz DrawLife

                        ret

; Works out where the ball should move to
; Outputs: hl - proposed ball x,y
ProposeBallMove:
                        ld hl, (proposedbally)
                        ld (oldbally), hl

                        ld a, (yballdir)               ; Get ball direction
                        and a
                        jr z, ProposeBallMoveX

                        add l                           ; move ball in that direction
                        ld l, a

                        ld (proposedbally), a

ProposeBallMoveX:
                        ld a, (xballdir)
                        and a
                        ret z

                        add h
                        ld h, a

                        ld (proposedballx), a
                        ret

CommitBallMove:
                        ld hl, (proposedbally)
                        call UpdateBallXY
                        ret

; input - ix set to spritetable
CheckLoseBall:
                        ld a, (ix+SPRITETABLE_Y)
                        cp 184                          ; Check if the ball is hitting the bottom
                        ret nz

                        call DrawLives

                        ld hl, lives
                        dec (hl)

                        xor a
                        ld (bonusadder), a              ; Remove any bonus accrued

                        call DrawLives
                        cp a                            ; set z to indicate a loss
                        ret

; LoadSprites - Load the sprite data into the sprite table. Always use index 0 for ball, index 1 for bat
LoadSprites:
                        ld ix, spritetable
                        ld a, 1
                        ld (ix+SPRITETABLE_FLAGS), a

                        ld hl, ball8x8Data
                        ld (ix+SPRITETABLE_PRESHIFT), hl

                        ld hl, INITIAL_BALL_COORDS
                        ld (proposedbally), hl
                        ld (oldbally), hl
                        call UpdateBallXY
                        ld (ix+SPRITETABLE_OLD_X), l

                        ld hl, (ix+SPRITETABLE_SCADD)
                        ld (ix+SPRITETABLE_OLD_SCADD), hl
                        ld de, (ix+SPRITETABLE_DATA)
                        ld (ix+SPRITETABLE_OLD_DATA), de

                        call CommitBallPosition

                        ld de, SPRITETABLE_SIZE
                        add ix, de

                        ; bat
                        ld a, 3
                        ld (ix+SPRITETABLE_FLAGS), a

                        ld hl, bat16x8Data
                        ld (ix+SPRITETABLE_PRESHIFT), hl

                        ld hl, INITIAL_BAT_COORDS
                        call UpdateSpriteXY
                        ld (ix+SPRITETABLE_OLD_X), l

                        ld hl, (ix+SPRITETABLE_SCADD)
                        ld (ix+SPRITETABLE_OLD_SCADD), hl
                        ld de, (ix+SPRITETABLE_DATA)
                        ld (ix+SPRITETABLE_OLD_DATA), de

                        ld h, INITIAL_BAT_X
                        ld l, 0
                        ld (ix+SPRITETABLE_X16), hl
                        ld h, INITIAL_BAT_Y
                        ld (ix+SPRITETABLE_Y16), hl

                        call CommitBatPosition
                        ret

; Checks if the bat and ball have collided
; inputs: hl - ball x, y
CheckBatCollision:
                        ld a, (yballdir)
                        cp 1
                        ret nz

                        ld a, l                         ; Check if ball is near bat
                        cp 176                          ; this is when the bottom of the ball crosses the bat line

                        ret c                           ; return if < 176, ball isn't near bat

                        push ix
                        ld de, SPRITETABLE_SIZE
                        add ix, de

                        ld bc, (ix+SPRITETABLE_Y)
                        pop ix

                        call CheckCollision8v16x8v8
                        ret nz

                        xor a
                        ld (bonusadder), a              ; Reset the score bonus when we hit the bat

                        ld a, b
                        add 14
                        ld c, a

                        ld a, b
                        add 2
                        ld b, a

                        ld a, (ix+SPRITETABLE_X)
                        add 4
                        
                        cp b
                        jr c, GoLeft

                        cp c
                        jr nc, GoRight

                        cp a

                        call z, Switch_YDir
                        jr z, Ball_HitY
                        ret

GoLeft:
                        ld a, -1
                        ld (xballdir), a
                        call Ball_HitX

                        call Switch_YDir
                        jr Ball_HitY

GoRight:
                        ld a, 1
                        ld (xballdir), a
                        call Ball_HitX
                        
                        call Switch_YDir
                        jr Ball_HitY

; The ball was hit on the y axis and so it needs to be moved back to the old position moved again
; Outputs: hl - new proposed ball x,y
Ball_HitY:
                        ld a, (oldbally)

                        ld bc, (yballdir)
                        add c

                        ld (proposedbally), a

                        ld hl, (proposedbally)
                        ret

; The ball was hit on the x axis and so it needs to be moved back to the old position moved again
; Outputs: hl - new proposed ball x,y
Ball_HitX:
                        ld a, (oldballx)

                        ld bc, (xballdir)
                        add c

                        ld (proposedballx), a

                        ld hl, (proposedbally)
                        ret

; input: ix - set to spritetable
CheckYEdgeCollision:
                        ld a, (ix+SPRITETABLE_Y)

                        cp 8                            ; Check if the ball is hitting the top
                        call z, Switch_YDir
                        jr z, Ball_HitY
                        ret

; input: ix - set to spritetable
CheckXEdgeCollision:
                        ld a, (ix+SPRITETABLE_X)

                        and a
                        jr nz, CheckRightEdge
                        call Switch_XDir
                        jr Ball_HitX

CheckRightEdge:
                        cp 247
                        ret nz

                        call Switch_XDir
                        jr Ball_HitX
                        ret

Switch_YDir:
                        ld a, (yballdir)                ; Load balldir into a
                        neg                             ; negate direction
                        ld (yballdir), a                ; store new direction
                        cp a                            ; set the z flag to indicate a switch occurred

                        ret

Switch_XDir:
                        ld a, (xballdir)
                        neg
                        ld (xballdir), a
                        cp a

                        ret

ReadKeys:       
                        ld bc, Row_YUIOP
                        in a, (c)

                        rra                               ; check for P
                        jr nc, MoveBatRight              ; move right

                        rra                               ; check for O
                        jr nc, MoveBatLeft

                        ld a, (batvelocitytarget)
                        and a
                        jr nz, TargetZeroVelocity

                        ld bc, Row_VCXZShift                                ; Check for c, complete level
                        in a, (c)

                        and 8
                        jr z, CompleteLevel

                        ld bc, Row_SpaceSymMNB                              ; check for <space>, launch ball
                        in a, (c)

                        and 1
                        ret nz

                        ld a, INITIAL_BALL_Y_DIR
                        ld (yballdir), a
                        ld a, INITIAL_BALL_X_DIR
                        ld (xballdir), a
                        ret

TargetZeroVelocity:
                        xor a
                        ld (batvelocitytarget), a

                        ld hl, (batvelocitydelta)
                        sub l                               ; 16bit neg to invert the velocity delta
                        ld l, a
                        sbc a, a
                        sub h
                        ld h, a
                        ld (batvelocitydelta), hl
                        ret

CompleteLevel:
                        xor a
                        ld (LevelBlockCount), a
                        ret

MoveBatLeft:
                        ld a, -BAT_VELOCITY_MAX
                        ld (batvelocitytarget), a
                        ld hl, -BAT_VELOCITY_DELTA
                        ld (batvelocitydelta), hl
                        ret

MoveBatRight:
                        ld a, BAT_VELOCITY_MAX
                        ld (batvelocitytarget), a
                        ld hl, BAT_VELOCITY_DELTA
                        ld (batvelocitydelta), hl
                        ret

UpdateBatPosition:
                        ld hl, (batvelocity)
                        ld a, (batvelocitytarget)

                        cp h
                        jr nz, UBP0

                        ld a, l
                        and a
                        jr z, UBP1

UBP0:
                        ld de, (batvelocitydelta)
                        add hl, de
                        ld (batvelocity), hl

UBP1:
                        ld a, h
                        and a
                        jr nz, UBP3

                        ld a, l
                        and a
                        ret z

UBP3:
                        push ix

                        ld ix, spritetable+SPRITETABLE_SIZE
                        ld de, (ix+SPRITETABLE_X16)
                        ex de, hl

                        add hl, de

                        ld a, h
                        cp 241
                        jr c, UBP2

                        ex af, af'
                        xor a
                        ld hl, NULL
                        ld (batvelocity), hl
                        ld (batvelocitydelta), hl
                        ld (batvelocitytarget), a
                        ex af, af'

                        cp 255
                        jr z, UBP2
                        cp 250
                        jr nc, UBP2

                        ld hl, 0xF000

UBP2:
                        ld (ix+SPRITETABLE_X16), hl

                        ld l, (ix+SPRITETABLE_Y)
                        call UpdateSpriteXY

                        ld a, (yballdir)
                        and a
                        call z, MoveBallToBat

                        pop ix
                        ret

CommitBatPosition:
                        push de, hl, ix

                        ld ix, spritetable + SPRITETABLE_SIZE
                        ld hl, (ix+SPRITETABLE_DATA)
                        ld de, (ix+SPRITETABLE_SCADD)

                        ld a, d                         ; convert pixel addr -> attribute addr
                        or 0x87                         ; see https://spectrumcomputing.co.uk/forums/viewtopic.php?t=3070
                        rra
                        rra
                        srl a
                        ld d, a

                        call AddCell
                        inc de
                        call AddCell
                        inc de
                        call AddCell

                        pop ix, hl, de
                        ret

CommitBallPosition:
                        push de, hl, ix

                        ld ix, spritetable
                        ld hl, (ix+SPRITETABLE_DATA)
                        ld de, (ix+SPRITETABLE_SCADD)

                        exx
                        ld hl, (ix+SPRITETABLE_Y)
                        exx

                        ld a, d
                        or 0x87
                        rra
                        rra
                        srl a
                        ld d, a

                        push bc

                        call AddCell

                        ld bc, 32
                        ex de, hl
                        add hl, bc
                        ex de, hl

                        ld c, 56
                        call AddCell

                        ld bc, 31
                        ex de, hl
                        sbc hl, bc
                        ex de, hl

                        ld c, 56
                        call AddCell

                        ld bc, 32
                        ex de, hl
                        add hl, bc
                        ex de, hl

                        ld c, 56
                        call AddCell

                        pop bc

                        pop ix, hl, de
                        ret

MoveBallToBat:
                        ld ix, spritetable

                        ld a, (ix+SPRITETABLE_X+SPRITETABLE_SIZE)
                        add 4

                        ld hl, (ix+SPRITETABLE_Y)
                        ld h, a

                        ld (proposedbally), hl
                        call UpdateSpriteXY

                        ret

; hl - sprite data
; de - attr address

; returns - hl + 8
AddCell:
                        push bc, de, hl

                        ld hl, UsedCellMap - ATTR_BASE
                        add hl, de                      ; Get the cell position

                        ld a, (hl)                      ; Check if it's already in use
                        cp 255
                        jp nz, ACCompositeCell
                                                        ; Get a new cell
                        ld a, (DrawCellCount)           ; Check if there is one free
                        cp MAX_CELLS
                        jp nc, ACFull                   ; None left
                        ld (hl), a                      ; record the new cell in the map
                        inc a                           ; increase the count
                        ld (DrawCellCount), a           ; update the count

                        push de                         ; Record new cell in used cell list
                        ex de, hl                       ; swap de&hl - de now points to offset in UsedCellMap
                        ld hl, (UsedCellListNext)       ; Store offset to UsedCellMap in UsedCellList
                        ld (hl), e
                        inc hl
                        ld (hl), d
                        inc hl
                        ld (UsedCellListNext), hl       ; Update the list
                        pop de                          ; restore de to attribute addr

                        ; Fill in new cell record
                        ld hl, (DrawCellListNext)
                        ld (hl), e                      ; Store attribute addr
                        inc hl
                        ld (hl), d
                        inc hl
                        inc hl

                        ld a, d                         ; convert the highbyte of attr addr to screen addr
                        add a
                        add a
                        add a
                        and d
                        ld (hl), a                      ; store high byte
                        inc hl

                        ex de, hl

                        ; de - bitmap space in DrawCellList
                        ; hl - attr address

                        push de, hl

                        call GetBrickAtAttr

                        pop hl                  ; hl - attr address
                        ex de, hl               ; de - attr address, hl - brick address

                        bit 0, e                ; get correct half of brick
                        jr z, ACCopyBrick
                        inc hl

ACCopyBrick:                
                        pop de                  ; de - address in drawcell list

                        exx                 
                        pop hl                  ; hl' - bitmap data
                        exx

                        dup 8
                        ld a, (hl)
                        exx
                        or (hl)
                        inc hl
                        exx

                        ld (de), a
                        inc hl
                        inc hl
                        inc de
                        edup

                        ld (DrawCellListNext), de

                        pop de, bc
                        ret

ACCompositeCell:
                        ld h, 0                         ; a * 12
                        ld l, a
                        add hl, hl
                        add hl, hl
                        ld d, h
                        ld e, l
                        add hl, hl
                        add hl, de

                        ld de, DrawCellList + 4
                        add hl, de

                        ex hl, de

                        pop hl

                        dup 8
                        ld a, (de)
                        or (hl)
                        ld (de), a
                        inc hl
                        inc de
                        edup

                        pop de, bc
                        ret

ACFull:
                        pop hl, de, bc
                        ret


ClearCells:
                        ld a, (DrawCellCount)
                        and a
                        ret z

                        push bc, hl

                        ld b, a
                        ld hl, UsedCellList
                        ld a, 255

CCClearUsedCell:
                        ld e, (hl)
                        inc hl
                        ld d, (hl)
                        inc hl
                        ld (de), a

                        djnz CCClearUsedCell

                        ld a, (DrawCellCount)
                        ld b, a

                        ld hl, DrawCellList

                        ld de, ClearCellList

CCClearCell:
                        push hl

                        dup 4
                        ld a, (hl)
                        ld (de), a
                        inc de
                        inc hl
                        edup

                        pop hl                          ; hl = start of drawcell

                        push hl                         ; store start of drawcell

                        push de                         ; store start of clearcell data

                        ld a, (hl)                      ; Get attr address
                        inc hl
                        ld h, (hl)
                        ld l, a

                        call GetBrickAtAttr             ; Get brick address in de

                        bit 0, l                        ; if the attr address is odd then we need the second
                        jr z, CCCopyBrick               ; half of the brick
                        inc de

CCCopyBrick:
                        pop hl                          ; pop the start of clearcell data into hl

                        dup 8                           ; copy the brick data into the clearcell data
                        ld a, (de)
                        ld (hl), a
                        inc de                          ; skip every other byte
                        inc de
                        inc hl
                        edup

                        ex de, hl                       ; de - next ClearCell, hl - end of brick data

                        pop hl                          ; hl - start of DrawCell
                        push de
                        ld de, CLEARCELL_SIZE
                        add hl, de                      ; hl - next drawcell
                        pop de                          ; de - next ClearCell

                        djnz CCClearCell                

                        ld a, (DrawCellCount)
                        ld (ClearCellCount), a
                        xor a
                        ld (DrawCellCount), a
                        ld hl, DrawCellList
                        ld (DrawCellListNext), hl
                        ld hl, UsedCellList
                        ld (UsedCellListNext), hl

                        pop hl, bc
                        ret

DrawVelocity:
                        push bc, de, hl
                        ld de, 0x5800

                        ld b, 32
DVErase:
                        ld a, 56
                        ld (de), a
                        inc de
                        djnz DVErase

                        ld bc, (batvelocity)
                        call absBC

                        ld a, b
                        and a
                        jr z, DVFraction

                        ld de, 0x5800
                        ld a, 8
DVDraw:
                        ld (de), a
                        inc de
                        djnz DVDraw

DVFraction:
                        ld a, c
                        and a
                        jr z, DVFinish

                        ld b, c
                        srl b
                        srl b
                        srl b
                        srl b
                        ld de, 0x5810
                        ld a, 16

DVDrawFraction:
                        ld (de), a
                        inc de
                        djnz DVDrawFraction

DVFinish:
                        pop hl, de, bc
                        ret

